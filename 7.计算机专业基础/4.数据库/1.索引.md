索引类别是概念上的说法：比如在MySQL的InnoDB存储引擎中，聚集索引默认是主键索引。

https://cloud.tencent.com/developer/article/1193302

### 一、索引有哪些分类？也说下二级索引、覆盖索引、回表是什么？

索引通常被用于数据库中，用来加速查询操作。根据不同的使用场景和数据类型，索引有很多种分类。常见的索引分类包括：

1. **聚簇索引 (Clustered index):** 聚簇索引将数据行存储在叶子节点上，**这种索引的顺序与表中数据的物理存储顺序相同**。一个表只能有一个聚簇索引。

2. **非聚簇索引 (Non-clustered index):** 非聚簇索引的叶子节点并不包含数据行的物理位置，而是包含了对应的聚簇索引键。非聚簇索引的顺序与数据在磁盘上的顺序无关，一个表可以有多个非聚簇索引。

3. **唯一索引 (Unique index):** 唯一索引保证索引列的唯一性，它的主要目标是避免重复的索引值。

4. **复合索引 (Composite index):** 复合索引是由两个或更多的列组成的索引，这些列的值组合在一起定义了索引的顺序。

你提到的二级索引、覆盖索引和回表是非聚簇索引相关的概念：

- **二级索引 (Secondary index):** 二级索引是另一种非聚簇索引的称谓，二级索引的键值指向聚簇索引的键值，而不是直接指向数据行。

  > 让我们通过一个简单的数据库表来解释二级索引。假设我们有一个“Employees”表，结构如下：
  >
  > | EmpID | EmpName | EmpRole   |
  > | ----- | ------- | --------- |
  > | 1     | Alice   | Manager   |
  > | 2     | Bob     | Developer |
  > | 3     | Charlie | QA        |
  > | 4     | David   | Developer |
  > | 5     | Emma    | QA        |
  >
  > 假设我们以`EmpID`作为聚簇索引（也就是主键），物理存储的数据行的顺序就和`EmpID`的顺序一致。
  >
  > 现在，假设我们经常需要按`EmpRole`来查询员工，为了加速这类	查询，我们可以创建一个以`EmpRole`为键值的二级索引。这个二级索引就像一个“快速查找表”，**其中的每一项都包含指向对应的聚簇索引（`EmpID`）的指针。**
  >
  > 二级索引的内容可能类似于：
  >
  > | EmpRole   | EmpID_Pointer |
  > | --------- | ------------- |
  > | Developer | 2, 4          |
  > | Manager   | 1             |
  > | QA        | 3, 5          |
  >
  > 当我们执行查询“查找所有的开发人员（Developer）”时，**数据库系统首先查找二级索引，找到对应的`EmpID`指针，然后再通过这些指针访问主表的数据行。**
  >
  > 这样，我们就无需在主表中扫描每一行数据来找到开发人员，大大提高了查询效率。这就是二级索引的作用。

- **覆盖索引 (Covering index):** 如果一个索引包含了查询所需的所有数据，则称该索引为覆盖索引。对于覆盖索引的查询，只需要访问索引，而不需要访问数据行，因此性能较好。

- **回表 (Back to the table):** 当无法使用覆盖索引满足查询，即查询的数据不在索引中时，需要通过索引中的键值回到数据表中获取数据，这个过程就叫做回表。由于涉及到额外的数据访问，回表的开销相对较大。

### 二、其他问题

1. 索引是不是越多越好，为什么？

   > 不是的，索引并不是越多越好。虽然索引可以提高查询速度，但过多的索引也会带来一些问题：
   >
   > 1. **增加写操作的成本**：当数据发生变化（如插入、删除、更新）时，索引也需要相应地进行修改。如果有很多索引，那么每次数据变化都需要更新所有的索引，这将大大增加写操作的成本。
   > 2. **占用更多的存储空间**：每个索引都会占用一定的存储空间。如果有很多索引，那么需要的存储空间也会相应地增加。
   > 3. **影响查询优化器的效率**：在处理查询时，MySQL查询优化器需要决定使用哪个索引。如果有很多索引，查询优化器需要花费更多的时间来选择最优的索引，这可能会影响查询的性能。

2. 聚集索引和非聚集索引概念的区别，它们的数据结构都是B+树吗？

   > **聚集索引**：
   >
   > - 聚集索引的特点是，它按照每张表的主键进行排序，并且直接包含了与每个键关联的行数据。换句话说，索引的逻辑顺序决定了表中行的物理存储顺序。因此，一张表只能有一个聚集索引。
   > - 聚集索引通常使用B+树数据结构，其中每个叶节点都包含了实际的行数据。这使得按照主键进行的查询非常高效，因为可以直接通过索引找到数据，而无需额外的读取操作。
   >
   > **非聚集索引**：
   >
   > - 非聚集索引，也被称为二级索引或辅助索引，是不改变表中行的物理顺序的索引。非聚集索引包含一个指向每个表行的指针，这通常是主键或者行的物理地址。
   > - 非聚集索引同样使用B+树数据结构，但与聚集索引不同的是，它的叶节点并不包含实际的行数据，而是包含指向行数据的指针。当通过非聚集索引进行查询时，数据库系统需要先通过索引找到指针，然后通过指针读取实际的数据，这被称为“回表”操作。
   >
   > 总的来说，聚集索引和非聚集索引在许多方面都有各自的优势和劣势。**聚集索引对于主键查询非常高效，但对于插入和删除操作可能较慢，因为可能需要重新组织存储的数据。非聚集索引可以提高非主键查询的性能，但可能需要额外的回表操作。**因此，选择使用哪种类型的索引需要根据具体的查询需求和数据分布来决定。
   >
   > ---
   >
   > **在InnoDB存储引擎中，主键索引（即默认的聚集索引）和非聚集索引都使用了B+树数据结构。**聚集索引的叶节点直接包含了完整的数据行，而非聚集索引的叶节点则包含了指向对应数据行的指针（如果非聚集索引不是基于主键创建的，则叶节点会包含主键的值作为指针）。
   >
   > ---
   >
   > ##### 如果我们要创建一个索引，它是非聚集索引且是唯一索引，是否可以使用如下语句？
   >
   > ~~~sql
   > CREATE UNIQUE INDEX idx_email
   > ON my_table(email);
   > ~~~
   >
   > 解释：
   >
   > 在SQL语句中，`CREATE INDEX`命令是用来创建索引的，而`UNIQUE`关键字是用来确保索引的值是唯一的。但这个命令并不能指定创建的索引是聚集的还是非聚集的。索引是否是聚集索引或非聚集索引，取决于数据库的具体实现和表的定义。
   >
   > 例如，**在MySQL的InnoDB存储引擎中，聚集索引默认是主键索引。**如果你没有明确指定表的主键，那么InnoDB会选择一个唯一非空的列作为聚集索引。如果没有这样的列，InnoDB会生成一个内部的ROW_ID作为聚集索引。所以，在这个例子中，如果`email`列不是表的主键，且表中没有其他的聚集索引，那么使用`CREATE UNIQUE INDEX idx_email ON my_table(email);`这个命令将会创建一个唯一的非聚集索引。但如果`email`列是表的主键，那么这个命令将会创建一个唯一的聚集索引。
   >
   > 所以，对于`CREATE UNIQUE INDEX idx_email ON my_table(email);`这个命令，我们不能确定创建的是聚集索引还是非聚集索引，这取决于数据库的具体实现和表的定义。

