> 左移、右移的原则是不改变数字的符号的情况下，进行扩大或缩小2^n倍的操作。

1. 左移

   <<是左移运算符；**正数'<<'会变大，负数'<<'会变小**

   左移运算符只有一个，因为对于有符号和无符号的数来说，**左移操作都只会在右边补0，不会改变数字的符号。**

2. 右移

   \>>是带符号右移运算符；**正数'\>>'会变小，负数'\>>'会变大**

   \>>>是无符号右移运算符；

   > 带符号右移运算符>>在右移过程中保持符号位不变，**用符号位填充空出的位；**
   >
   > 无符号右移运算符>>>则不考虑符号位，**用0填充空出的位，对于负数，可能会变成正数。**
   >
   > 在大多数情况下，我们应该使用带符号右移运算符>>，因为它可以正确地处理带符号数的右移操作。只有在需要对无符号数进行右移操作时，才需要使用无符号右移运算符>>>。

   >例如：**（原码转换成反码，原码转换成补码，补码还原成原码的过程，进行取反操作时，计算机会保持符号位不变）**
   >
   >~~~java
   >public class Test {
   >    public static void main(String[] args) {
   >        /*
   >        * 对于-8来说，它的原码是1000 0000 0000 0000 0000 0000 0000 1000，因为第一位是符号位，表示负数。计算机中，负数一般用它的补码表示。
   >        * 然后，将其取反得到1111 1111 1111 1111 1111 1111 1111 0111，再将其加1得到1111 1111 1111 1111 1111 1111 1111 1000，
   >        * 这个二进制表示就是-8的补码形式。因此，二进制表示-8要写成11111111111111111111111111111000，这就是-8的补码形式。
   >        * -----
   >        * >>右移一位，1111 1111 1111 1111 1111 1111 1111 1000 -> 1111 1111 1111 1111 1111 1111 1111 1100 （左边用符号位补齐）
   >        * 对这个补码，取反，加1，得到原码：1000 0000 0000 0000 0000 0000 0000 0100（还原成原码的过程，取反符号位不变），十进制表示为-4。
   >        * -----
   >        * <<左移一位，1111 1111 1111 1111 1111 1111 1111 1000 -> 1111 1111 1111 1111 1111 1111 1111 0000 （右边用符号位补齐）
   >        * 对这个补码，取反，加1，得到原码：1000 0000 0000 0000 0000 0000 0001 0000（还原成原码的过程，取反符号位不变），十进制表示为-16。
   >        * */
   >        int a = -8;
   >        System.out.println(a >> 1);//-4
   >        System.out.println(a >>> 1);//2147483644，负数不能用>>>位移，会变成正数
   >        System.out.println(a << 1);
   >
   >    }
   >}
   >~~~
   >
   
3. 与&

4. 或|

5. 取反~

   > **包括符号位在内**，进行按位取反

   ~~~java
   int a = -8;
   System.out.println(~a);//7
   ~~~

   