### 一、网络协议有几层，分别介绍下

计算机网络通常采用分层的协议体系，最为著名的是OSI（开放系统互联）模型和TCP/IP模型。这里我们主要介绍**TCP/IP模型，它包括4个层次：链路层、网络层、传输层和应用层。**每一层都有其特定的功能和相应的协议。

1. 链路层（Link Layer）： 链路层是网络协议的最底层，负责在**相邻网络节点之间传输数据**。链路层的主要功能包括帧封装、物理寻址、流量控制、差错控制等。常见的链路层协议有以太网（Ethernet）、Wi-Fi（无线局域网）等。
2. 网络层（Network Layer）： **网络层负责将数据包从源节点传输到目标节点，处理数据包的路由选择和寻址。网络层的主要协议是IP协议（Internet Protocol），它定义了数据包的格式和如何在不同网络之间进行传输**。除了IP协议外，还有一些辅助协议如ICMP（Internet Control Message Protocol，用于网络故障排查和诊断）和IGMP（Internet Group Management Protocol，用于组播通信）。
3. 传输层（Transport Layer）： 传输层负责**在源节点和目标节点之间建立可靠或不可靠的数据传输通道**。传输层协议主要包括TCP（传输控制协议，Transmission Control Protocol）和UDP（用户数据报协议，User Datagram Protocol）。TCP提供可靠的数据传输，确保数据完整无误地到达目的地；UDP提供不可靠的数据传输，但具有更低的延迟和更高的传输效率。
4. 应用层（Application Layer）： 应用层是网络协议栈的最顶层，**负责处理用户级别的通信和服务**。应用层协议包括HTTP（超文本传输协议，**用于Web通信**）、FTP（文件传输协议，用于文件上传和下载）、SMTP（简单邮件传输协议，用于电子邮件发送）、POP3/IMAP（邮件接收协议，用于电子邮件接收）等。

这些层次之间的协作使得计算机网络能够高效、可靠地进行数据通信。数据在传输过程中会逐层封装和解封装，每一层只需关心自己的功能和与相邻层的通信，降低了复杂性。

### 二、tcp协议和udp协议是哪一层的协议，讲一下他们之间的区别，以及他们各自的应用场景

TCP协议（传输控制协议）和UDP协议（用户数据报协议）都属于传输层协议。它们在数据传输过程中有一些明显的区别，分别适用于不同的应用场景。

TCP协议的主要特点：

1. 可靠性：TCP提供可靠的数据传输，通过确认、重传、流量控制等机制确保数据完整无误地到达目的地。
2. 有序性：TCP保证数据包按照发送顺序到达接收端。
3. 面向连接：TCP在数据传输前需要建立连接，**通信双方需要进行三次握手。**
4. 流量控制：TCP通过滑动窗口机制进行流量控制，防止接收方被发送方的数据包淹没。

TCP适用的应用场景主要包括：

1. Web浏览：**HTTP和HTTPS协议都基于TCP协议**，以确保网页内容的完整传输。
2. 文件传输：FTP协议使用TCP进行文件上传和下载，确保文件传输的可靠性。
3. 邮件传输：SMTP、POP3和IMAP协议都基于TCP，以保证邮件数据的可靠传输。

UDP协议的主要特点：

1. 无连接：UDP无需建立连接，直接发送数据。
2. 不可靠性：UDP不保证数据包的可靠传输，可能出现丢包、重复或乱序等情况。
3. 低延迟：UDP的传输效率较高，因为它**不需要进行握手、确认和重传等操作。**
4. 轻量级：UDP协议头部较短，额外开销较小。

UDP适用的应用场景主要包括：

1. 实时通信：如VoIP（语音通信）、视频会议等，它们对实时性要求较高，而对数据传输的完整性要求相对较低。
2. 在线游戏：许多在线游戏使用UDP进行数据传输，因为游戏对低延迟和高效率的要求较高。
3. 流媒体传输：如IPTV、直播等，它们对实时性要求较高，可以容忍一定程度的数据丢失。

总之，TCP和UDP协议分别适用于不同的应用场景，**TCP更注重数据的可靠性，适用于对数据完整性要求较高的场景；而UDP更注重传输效率和实时性，适用于对实时性和低延迟要求较高的场景。**

### 三、介绍下http协议

#### 1）HTTP版本

* HTTP（超文本传输协议，Hypertext Transfer Protocol）是一个应用层协议，它用于在因特网上进行数据通信。HTTP基于请求-响应模式，通常在客户端（例如，Web浏览器）和服务器端之间传输HTML、CSS、JavaScript等Web文档。

* HTTP 是一种应用层协议，是基于 TCP/IP 通信协议来传递数据的，其中 HTTP1.0、HTTP1.1、HTTP2.0 均为 TCP 实现，HTTP3.0 基于 UDP 实现。现主流使用 HTTP1.0 和 HTTP3.0。

* http1.0 :  短链接

  http1.1:  长连接  持久连接，即可以复用TCP连接，避免了第二次TCP连接时的三次握手

  http2.0:  ++++++++++长连接+多路复用(是提高传输信道的利用率和传输效率的一种通信技术)
  
  >  HTTP/1.0 中，每个请求/响应都需要建立新的 TCP 连接，因此会有很多 TCP 连接的开销。
  >
  > 在 HTTP/1.1 中，引入了持久连接（keep-alive）特性来解决这个问题，使得在一个 TCP 连接中可以进行多个请求/响应。
  >
  > 然而，即便如此，HTTP/1.1 的请求仍然是串行的。
  >
  > 而在 HTTP/2 中，引入了多路复用技术，使得在一个 TCP 连接中**可以并行进行多个请求/响应。**

注意： 当我们访问一些网页时，是显示通过 HTTPS 来进行通信的，并且当下大多数的网页都是通过 HTTPS 来进行通信的，因为 HTTPS 在 HTTP 的基础上做了一个加密的工作。

#### 2）http的数据结构

HTTP的数据结构主要包括请求和响应两部分，每一部分都包含起始行、头部(header)和主体(body)。

1. **请求：**

   **请求行:** 请求行包含请求的方法（如GET，POST），请求的URI（统一资源标识符，用于标识请求的资源），以及HTTP的版本。

   **请求头部:** 请求头部包含了一些关于请求或请求资源的更多信息，例如客户端的类型(User-Agent)，支持的内容类型(Accept)，进行身份验证的信息等。

   **请求主体:** 请求主体包含了实际发送到服务器的数据，通常用于POST或PUT请求。**对于GET请求，请求主体通常是空的。**

2. **响应：**

   **状态行:** 状态行包含HTTP版本，一个状态码(例如200表示成功，404表示未找到)，以及一个简短的状态消息。

   **响应头部:** 响应头部包含了一些关于响应或响应的资源的更多信息，例如服务器的类型，响应的日期，响应的内容类型等。

   **响应主体:** 响应主体包含了实际返回的数据，例如HTML文档，JSON数据，图像等。

这是HTTP的基本数据结构。需要注意的是，HTTP是基于文本的协议，因此，所有的请求和响应数据都是可读的。然而，随着HTTP/2的引入，部分数据（如头部）可以以二进制形式进行传输，以提高效率和安全性。

### 四、讲一下http协议和https协议之间的区别，以及他们各自的应用场景

HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）都是用于在网络上传输数据的协议。它们之间的主要区别在于安全性和加密方面。

1. 安全性： HTTP是明文传输协议，数据在传输过程中没有加密，容易被中间人攻击者截获和篡改。而HTTPS在HTTP的基础上增加了SSL/TLS加密层，确保数据在传输过程中的安全性和完整性。
2. 端口号： HTTP默认使用端口80，而HTTPS默认使用端口443。
3. 证书： HTTPS需要服务器获取并安装SSL证书。当用户访问一个HTTPS网站时，浏览器会验证服务器提供的证书的有效性，从而确认该网站的真实性和安全性。
4. 性能： 由于HTTPS需要进行加密和解密操作，因此相比HTTP可能存在一定的性能开销。然而，随着现代硬件和软件优化的发展，这种性能差距已经变得相对较小。

应用场景：

HTTP适用于那些对安全性要求不高的场景，如一般的信息浏览、新闻阅读等。然而，随着互联网安全意识的提高和技术的发展，越来越多的网站都在转向HTTPS。

HTTPS适用于对安全性和隐私保护要求较高的场景，如电子商务、金融、政府等领域。对于涉及到个人信息、隐私数据、敏感信息等内容的传输，HTTPS可以提供更好的安全保障。

总之，**HTTP和HTTPS的主要区别在于安全性和加密方面。**随着互联网安全意识的普及和搜索引擎对HTTPS的优先支持，越来越多的网站都在采用HTTPS以提高用户的安全体验。

### 五、说下get和post请求的区别

GET和POST都是HTTP协议中的请求方法，它们用于与服务器进行通信。尽管它们都可以发送请求并获取响应，但它们之间还是存在一些显著的区别。

1. 传输数据的方式： GET请求将参数附加在URL中，形式为“URL?key=value”。这意味着GET请求的参数会显示在浏览器的地址栏中。而POST请求将参数放在请求体（request body）中进行传输，不会在地址栏中显示。
2. 数据长度的限制： 由于GET请求将参数放在URL中，因此受到URL长度的限制，通常不能传输过长的数据。而POST请求将数据放在请求体中，理论上没有长度限制，可以传输较大的数据。
3. 安全性： GET请求的参数在URL中显示，这可能导致敏感信息泄露，如密码、身份信息等。POST请求将数据放在请求体中，不会直接显示在地址栏中，相对来说安全性较高。但需要注意的是，POST请求本身并不是加密的，为了确保数据安全，还需要采用其他加密手段，如SSL/TLS等。
4. 缓存和历史记录： GET请求的URL包含参数信息，容易被浏览器缓存和保存在历史记录中。这有时可能导致不必要的服务器请求。POST请求由于不在URL中包含参数信息，不易被浏览器缓存和保存在历史记录中。
5. 幂等性和副作用： GET请求通常被认为是幂等的，即多次执行相同的GET请求，服务器的状态不会改变。GET请求用于获取数据，而不应该修改服务器上的数据。而POST请求可能产生副作用，导致服务器状态发生变化，例如创建新资源、修改现有资源等。

总之，GET和POST请求在传输数据方式、数据长度限制、安全性、缓存和历史记录以及幂等性和副作用等方面有所区别。**GET请求主要用于获取数据，而POST请求通常用于提交数据。**在实际应用中，需要根据具体需求选择合适的请求方法。

### 六、说下浏览器输入url网址的时候，从输入到显示页面的过程

1. DNS 解析：首先，浏览器需要将域名解析为对应的地址。**浏览器会向 DNS 服务器发起查询请求，DNS 服务器会返回与域名对应的 IP 地址。**
2. 建立 TCP 连接：在获取到 IP 地址后，浏览器会向服务器发起 TCP 连接请求。**这个过程通常包括“三次握手”，在握手成功后，浏览器与服务器之间就建立了可靠的 TCP 连接。**
3. 发送 HTTP 请求：TCP 连接建立成功后，浏览器会通过该连接向服务器发送 HTTP 请求。请求中包含了请求的资源、方法（通常为 GET 方法）以及其他相关信息（如请求头、Cookie 等）。
4. 服务器处理请求：服务器接收到浏览器的 HTTP 请求后，会进行相应的处理。这可能包括查询数据库、执行后端代码等操作。处理完成后，服务器会将请求的资源（如 HTML、CSS、JavaScript 文件等）封装成 HTTP 响应。
5. 接收响应并解析：浏览器接收到服务器返回的 HTTP 响应后，会对响应数据进行解析。首先解析 HTML 文档，然后根据 HTML 中引用的其他资源（如 CSS、JavaScript、图片等），再次发起请求获取这些资源。
6. 渲染页面：浏览器获取并解析完所有资源后，会根据 HTML 和 CSS 构建 DOM（文档对象模型）和 CSSOM（CSS 对象模型），然后将它们合成渲染树（Render Tree）。接着，浏览器会进行布局（Layout）操作，计算出各个元素在页面上的位置。最后，浏览器进行绘制（Paint）操作，将渲染树中的元素绘制到屏幕上。
7. JavaScript 执行：浏览器在解析和渲染过程中，还会执行页面中的 JavaScript 代码。JavaScript 可以对 DOM 和 CSSOM 进行操作，从而实现动态交互效果。

这个过程可能会受到网络环境、服务器响应速度、浏览器性能等因素的影响。在整个过程中，浏览器还可能执行一些优化操作，如缓存 DNS 查询结果、HTTP 缓存等，以提高页面加载速度。

### 七、介绍下三次握手和四次挥手

三次握手（Three-Way Handshake）和四次挥手（Four-Way Handshake）是TCP协议中用于建立和终止连接的过程。**TCP是一种面向连接的传输层协议，它通过这些过程确保数据的可靠传输。**

#### 1.三次握手（建立连接）

三次握手的目的是在客户端和服务器之间**建立可靠的TCP连接。**具体步骤如下：

1. 第一次握手：客户端发送SYN包**（标志位SYN=1，发送序号Seq=X）**到服务器，表示客户端希望建立连接。此时客户端的状态为**SYN_SENT。**
2. 第二次握手：服务器收到SYN包后，如果同意建立连接，会发送一个**SYN/ACK包（SYN=1，ACK=1，Seq=Y，Ack=X+1）**作为响应。服务器在发送SYN/ACK包之前需要分配缓冲区资源和其它必要的数据结构，此时服务器的状态为**SYN_RECEIVED。**
3. 第三次握手：客户端收到SYN/ACK包后，会发送一个**ACK包（ACK=1，Seq=X+1，Ack=Y+1）**给服务器，表示连接已经建立。客户端和服务器此时都进入**ESTABLISHED**状态，可以开始传输数据。

三次握手通过**交换SYN和ACK包**确保连接的双向可靠性，同时也用于同步客户端和服务器的初始序列号（Seq）。

#### 2.四次挥手（终止连接）

四次挥手的目的是在客户端和服务器之间**终止已建立的TCP连接。**具体步骤如下：

1. 第一次挥手：当客户端认为数据传输完成后，会发送一个**FIN包（FIN=1，Seq=U）**给服务器，表示客户端希望关闭连接。此时**客户端的状态为FIN_WAIT_1**。
2. 第二次挥手：服务器收到FIN包后，会发送一个**ACK包（ACK=1，Seq=V，Ack=U+1）**给客户端，表示已经收到了客户端的关闭请求。此时**服务器的状态为CLOSE_WAIT，客户端的状态变为FIN_WAIT_2**。
3. 第三次挥手：当服务器完成数据传输后，会发送一个**FIN包（FIN=1，Seq=W）**给客户端，表示服务器也希望关闭连接。此时**服务器的状态为LAST_ACK**。
4. 第四次挥手：客户端收到服务器的FIN包后，会发送一个**ACK包（ACK=1，Seq=U+1，Ack=W+1）**给服务器，表示连接已经关闭。**客户端的状态变为TIME_WAIT，等待一段时间后释放资源并进入CLOSED状态。收到ACK包的服务器会立即关闭连接，进入CLOSED状态。**

四次挥手通过**交换FIN和ACK包**确保连接的双向关闭。注意，TCP连接的关闭是一个双向过程，客户端和服务器需要分别关闭