* finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？

  ~~~
  1.垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；
  2. 在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，就要在finaliztion里去调用C的释放函数。
  ~~~

* 重排序遵守的规则as-if-serial？

  ~~~
  1. 不管怎么排序，结果不能改变
  2. 不存在数据依赖的可以被编译器和处理器重排序
  3. 一个操作依赖两个操作，这两个操作如果不存在依赖可以重排序
  4. 单线程根据此规则不会有问题，但是重排序后多线程会有问题
  ~~~

* as-if-serial规则和happens-before规则的区别

  ~~~
  1. as-if-serial规则和happens-before规则都是并发编程的规范
  2. as-if-serial语义保证单线程内程序的执行结果不被改变
  3. happens-before关系保证正确同步的多线程程序的执行结果不被改变。
  4. 两者都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。
  ~~~

* synchronized关键字最主要的使用方式：

  ~~~
  【修饰实例方法、变量或代码块；修饰静态方法、变量或代码块；。
  修饰实例方法、变量或代码块，是给**实例对象加锁**；修饰静态方法、变量或代码块，是给**当前类加锁**】
  ~~~

* 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式？

* synchronized 底层实现原理？

  ~~~
  1. Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成。每个对象有一个监视器锁(monitor)。
  锁的基本单位就是对象的内部锁（也称为监视器锁或 monitor），如果其他线程正在持有该对象的内部锁，那么当前线程将被阻塞，直到其他线程释放该锁。一旦当前线程获得了内部锁，它就可以执行由 `synchronized` 保护的代码，并保持该锁直到退出该代码块。
  2. JDK1.6之后对synchronized锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
  ~~~

* 什么是自旋？

* 多线程中 synchronized 锁升级的原理是什么？

* synchronized 和 Lock 有什么区别？

* synchronized 和 ReentrantLock 区别是什么？

* volatile 关键字的作用？

  ~~~
  1. volatile 关键字保证了可见性和禁止指令重排
  2. 与 CAS 无锁编程策略结合，可以保证对单个变量操作的原子性
  3. 用volatile修饰long和double可以保证其操作原子性
  ~~~

* Java 中能创建 volatile 数组吗？

  ~~~
  能，但volatile 标示符只能保证 指向数组的引用 的并发安全性，而不能保证数组中的元素。
  ~~~

* volatile 变量和 atomic 变量有什么不同？

  ~~~
  1. 原子变量主要是通过 java.util.concurrent.atomic 的一系列类来实现的，例如 AtomicInteger、AtomicLong、AtomicBoolean 等。AtomicInteger 类是 Java 中提供的一个原子变量类，它提供了一些原子操作方法，这些方法能够保证在并发情况下对变量进行安全的读写操作。原子变量适用于多线程环境下的并发编程，能够避免因为竞态条件而导致的数据不一致或者数据丢失等问题，从而提高程序的并发性能和可靠性。
  2. volatile 只能保证可见性，不能保证原子性
  ~~~

* 什么是原子类

  > 简单来说，原子类就是实现**CAS无锁模式**的算法。未成功的线程可以**像自旋锁一样**，继续尝试，一直等到执行成功。
  >
  > java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上进行无锁的线程安全编程。