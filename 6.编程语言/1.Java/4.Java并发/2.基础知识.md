* 什么是上下文切换?

  > 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
  
* 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？

  > 1. new一个Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行run() 方法的内容，这是真正的多线程工作。
  > 2. 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
  >
  > 总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。
  
* Java线程的中断机制？

  > 使用interrupt()方法来结束线程，可以避免粗暴结束线程带来的线程安全问题。
  
  ![image-20230313160840180](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230313160840180.png)
  
  为什么使用LockSupport.park()方法进入阻塞状态的线程，调用interrupt()不会抛出InterruptedException异常？
  
  > * LockSupport.park()方法通过native方法调用操作系统的原语，实现挂起线程。
  > * 有一些可中断的阻塞方法（如Thread.sleep()、Object.wait()等），这些方法在执行过程中会**使用isinterrupted()等方法检查线程的中断状态**，如果线程的中断状态被设置为true，就会抛出InterruptedException异常，以提醒线程响应中断并进行必要的处理。
  > * 但是，LockSupport.park()方法不属于可中断的阻塞方法。在调用LockSupport.park()方法时，线程只是进入一种等待状态，**并且可以在任何时候、任何地点被唤醒**。如果线程在阻塞期间被中断，LockSupport.park()方法会立即返回，并且线程的中断状态会被设置为true，但不会抛出InterruptedException异常。
  > * 因此，对于使用LockSupport.park()方法的线程，需要检查线程的中断状态来响应中断事件，并进行必要的处理，以确保程序的正确性和健壮性。
  >
  > **比如，LockSupport.park()方法可以用于在ReentrantLock中，让线程进入等待队列，等待被唤醒。此时对等待队列中的线程调用interrupt()方法，线程不会立即抛出中断异常，而是存储该中断状态值，直到获取锁之后才抛出异常。**