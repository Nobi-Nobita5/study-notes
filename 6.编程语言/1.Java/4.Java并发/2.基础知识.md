* 什么是上下文切换?

  > 上下文切换（Context Switch）通常是指操作系统在调度不同任务（进程或线程）时，保存当前任务的状态（上下文）并恢复另一个任务的状态（上下文）的过程。上下文切换使得多个任务可以在单个处理器上共享执行时间，从而实现任务之间的并发执行。
  >
  > 在操作系统中，我们可以将上下文切换分为两类：
  >
  > 1. 用户态与内核态之间的上下文切换：这种上下文切换发生在同一个进程中，当进程需要执行特权操作（如系统调用、异常处理等）时，会从用户态切换到内核态。执行完特权操作后，进程会从内核态切换回用户态。这种上下文切换涉及到对处理器状态的保存和恢复，例如程序计数器、寄存器、内存管理单元等。
  > 2. 进程或线程之间的上下文切换：这种上下文切换发生在操作系统调度器决定暂停当前运行的进程或线程，并运行另一个进程或线程时。这种切换涉及到保存当前进程或线程的上下文（包括程序计数器、寄存器、内存映射等）并恢复下一个进程或线程的上下文。
  >
  > 上下文切换可能会导致性能开销，因为保存和恢复上下文需要时间和处理器资源。频繁发生的上下文切换可能会降低系统整体性能。为了减少上下文切换的开销，操作系统会采用一些策略，例如合理的任务调度算法、缓存管理优化等。
  
* 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？

  > 1. new一个Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行run() 方法的内容，这是真正的多线程工作。
  > 2. 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
  >
  > 总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。
  
* Java线程的中断机制？

  > 使用interrupt()方法来结束线程，可以避免粗暴结束线程带来的线程安全问题。该方法会向目标线程发送中断信号，而不是直接终止线程。目标线程可以在执行时检测到中断信号，并根据需要进行清理和关闭。
  
  ![image-20230313160840180](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230313160840180.png)
  
  为什么使用LockSupport.park()方法进入阻塞状态的线程，调用interrupt()不会抛出InterruptedException异常？
  
  > * 一些可中断的阻塞方法（如Thread.sleep()、Object.wait()等），这些方法在执行过程中会**使用isinterrupted()等方法检查线程的中断状态**，如果线程的中断状态被设置为true，就会抛出InterruptedException异常，以提醒线程响应中断并进行必要的处理。
  > * 但是，LockSupport.park()方法不属于可中断的阻塞方法。**因为LockSupport类没有定义任何受检查异常，包括InterruptedException异常。**LockSupport.park()方法通过native方法调用操作系统的原语，实现挂起线程。**在调用LockSupport.park()方法时，线程只是进入一种等待状态，**并且可以在任何时候、任何地点被唤醒**。如果线程在阻塞期间被中断，LockSupport.park()方法会立即返回，并且线程的中断状态会被设置为true，但不会抛出InterruptedException异常。
  > * 因此，对于使用LockSupport.park()方法的线程，需要检查线程的中断状态来响应中断事件，并进行必要的处理，以确保程序的正确性和健壮性。
  >
  > **比如，LockSupport.park()方法可以用于在ReentrantLock中，让线程进入等待队列，等待被唤醒。此时对等待队列中的线程调用interrupt()方法，线程不会立即抛出中断异常，而是存储该中断状态值，直到获取锁之后才抛出异常。**