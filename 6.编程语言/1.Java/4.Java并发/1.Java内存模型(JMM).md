#### 一、硬件内存模型

![image-20230304173631263](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230304173631263.png)

1. 起初CPU之间都是共用主存，但随着CPU的发展，CPU运算速度越来越快，跟内存的速度已经有好几个量级的差别了，所以为了提高CPU的利用率（避免执行一个指令等待很长的内存IO时间），**在CPU和内存之间设置了高速缓存**（L1，L2，L3，越靠近CPU速度越快，同时越贵，其中L1和L2是CPU独享的，L3是CPU共享的），然后使用的时候会将主存的数据拷贝进去高速缓存中（当然这里并不是拷贝所有，下面会讲拷贝哪里，怎么拷贝），**相当于CPU之后只需要跟L1拿数据，速度是相当快的，就提高了CPU的利用率了**，但是，这又带来了另外一个问题，怎么保证**缓存的一致性**呢？正是**由于每个CPU都会从主存中拷贝一份数据到自己的高速缓存中，一个CPU一旦改变数据，怎么同步到其他CPU的缓存中呢？**

2. 现代计算机是通过**缓存一致性协议+总线锁**来保证数据一致性的。
   缓存一致性协议有很多种，这里以**Intel的MESI**为例介绍其怎么保证数据一致性的

   ![image-20230304173909751](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230304173909751.png)

   **MESI协议**里面定义了缓存行有四种状态：**修改，独享，共享，失效**，分别对应字母MESI。

   > 1. CPUA读取缓存行X时，由于还没有其他CPU访问过，此时CPUA中的缓存行状态为独享；
   >
   > 2. 过了一会CPUB也来访问X，发现有人访问过该缓存行了，就通知CPUA修改其状态为共享，CPUB中的缓存行状态也为共享；
   > 3. 过了一会，CPUB修改了自己缓存中X中的数据，那么CPUB中的X的状态为modify，此时CPUA的X的还是共享，**当CPUB要将X写回主存时**，主存发现要写回的X的状态是modify，于是通知其他拥有X的CPU修改他们的X的状态为失效，等其他CPU修改好后，才将X写回主存；
   > 4. 过了一会，CPUA想要操作自己缓存中X中的数据，发现X的状态是失效，就会重新去主存上读取新的X到自己缓存中。

3. 这里了解一下主存的数据是怎么拷贝进高速缓存的

   CPU读取某个数据的时候，访问L1，L1没有就从L2读，L2没有就从L3读，L3没有就从主存读，读到数据，依次拷贝进L3，L2，L1。但并不是用到哪个数据就拷贝哪个数据，这样效率太低，而是将跟读取的数据在同一行的数据一起拷贝进高速缓存中，这样一行的数据也叫缓存行，CPU就是以缓存行为单位读取数据的，大小为64字节。

   但是缓存行也会产生为伪共享问题：假如一个缓存行中有数据A和B，CPUA和CPUB的高速缓存中都有该缓存行，CPUA只需要操作数据A，CPUB只需要操作数据B，在该场景下，假如CPUB不断操作数据B，CPUA就需要不断更新自己的缓存，但是CPUA其实是不需要关注数据B的，也就是数据B的变化其实CPUA是不关心的，它只会操作数据A。这就是**伪共享带来的效率问题**。可以用**缓存行对齐**来解决该问题，

   上述问题，只要数据A和数据B位于不同缓存行，是不是就没有上面的问题了？是的，所以如何将A和B分开呢？我们知道一个缓存行是64字节，只需要在AB前后各自补充几个多余变量来填充缓存行的大小到64字节即可将A和B分开在不同缓存行了。

#### 二、Java内存模型(JMM)

1. **JMM的由来**

   在之前，C/C++直接使用硬件的内存模型作为自己的内存模型，**而不同的平台硬件的内存模型不一样，**就会出现由于不同平台上内存模型的差异造成一套程序在**一套平台上完全正常运行，而到了别的平台就会出错的问题**，只能针对不同平台定制化开发。**因此Java定义了自己的内存模型**，它是在硬件内存模型基础上**更高层的抽象和增强**，屏蔽了各种硬件和系统对内存访问的差异性，以实现Java程序在任何平台下都能达到一致的内存访问效果。

2. **JMM的概念**

   JVM内部**每个线程都有自己的工作内存**，进程内所有线程**共享主内存**，线程并不会直接对主内存上的数据直接操作，而是将数据拷贝进自己的工作内存，对数据的操作也是在自己的工作内存里面完成的，线程之间的工作内存不能直接访问。

   即JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。JMM抽象示意图：

   ![image-20230304180342161](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230304180342161.png)
   从图中可以更直观的看出，每个线程的内存都是独立的，线程对变量的操作只能在工作内存中进行，然后刷回到主存。这便是 Java 内存模型定义的线程基本工作方式。

   > JMM 的规定小结：
   >
   > * 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。
   > * 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
   > * 线程对变量的所有的操作（读，写）都必须在工作内存中完成，而不能直接读写主内存中的变量。
   > * 不同线程之间也**不能直接访问对方工作内存**中的变量，**线程间变量值的传递需要通过主内存**中转来完成。
   >
   > **总之，Java 内存模型规定了【什么时候】、【如何】看到由其他线程修改过后的共享变量的值，以及在必须时【如何同步的】访问共享变量。**

3. **JMM 的八种内存交互操作**

   为了更直观，先来看看这张图吧：

   ![image-20230304180656923](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230304180656923.png)
   
   > * lock(锁定)：作用于主内存中的变量，一个变量在同一时间只能被一个线程锁定，即把变量标识为线程独占状态。
   > * read(读取)：作用于主内存变量，表示把一个变量值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。
   > * load(载入)：作用于线程的工作内存的变量，表示把 read 操作从主内存中读取的变量值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。
   > * use(使用)：作用于线程的工作内存中的变量，表示把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。
   > * assign(赋值)：作用于线程的工作内存的变量，表示把执行引擎返回的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。
   > * store(存储)：作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便下一步的 write 操作使用。
   > * write(写入)：作用于主内存的变量，表示把 store 操作从工作内存中得到的变量的值放入主内存的变量中。
   > * unlock(解锁)：作用于主内存的变量，表示把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

   JMM 还规定了以上八种操作需按照如下规则进行：
   
   > * 不允许read 和 load、store 和 write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
   > * 不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
   > * 不允许线程将没有 assign 的数据从工作内存同步到主内存。
   > * 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施 use 和 store 操作之前，必须经过 load 和 assign 操作。
   > * 一个变量同一时间只能有一个线程对其进行 lock 操作。但 lock 操作可以被同一条线程重复执行多次，多次 lock 之后，必须执行相同次数 unlock 才可以解锁。
   > * 如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。
   > * 如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。
   > * 一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。
   
4. **JMM 三大特征**

   JMM 三大特征分别是：原子性，可见性，有序性。整个 JMM 实际上也是围绕着这三个特征建立起来的，并且也是 Java 并发编程的基础。**但有时我们编写的代码块，是不满足这三个特征的**，下面会介绍怎样使得我们的代码满足这三大特征。

   **1）原子性**

   原子性是指一个操作是不可分割、不可中断的，要么全部执行成功要么全部执行失败。

   JMM 只能保证对基本数据类型的变量的读写操作是原子性的，但 long 和 double 除外（long 和 double 的非原子性协定）。

   我们来看看下面的例子：

   ~~~java
   int x = 1;
   int y = x;
   x ++;
   ~~~

   上面三行代码只有第一行是原子性操作，基本类型赋值操作，必定是原子性操作。

   第二行代码先读取 x 变量的值，再进行赋值给 y 变量，进行了两个操作，不能保证原子性。

   第三行代码先读取 x 变量的值，再进行加 1，最后再赋值给 x 变量，进行了三个操作，不能保证原子性。

   > **如何解决？**
   >
   > 在并发环境下，为了保证原子性，Java 提供了 synchronized 关键字。因此在 **synchronized 修饰**的代码块之间的操作都是**原子性**的。

   **2）可见性**

   可见性是指所有线程都能看到共享内存的最新状态。即当一个线程修改了一个共享变量的值时，其他线程能够立即看到该变量的最新值。

   **由于JMM每个线程的内存都是独立的，线程对变量的操作只能在工作内存中进行，然后刷回到主存。**所以多线程并发操作同一个数据的时候，就会有缓存不一致的问题，也就是**可见性问题**。

   > **如何解决？**
   >
   > 保证可见性的底层原理其实就是MESI协议，但MESI协议并没有规定CPU里面修改的数据**啥时候写回主存**。但配合synchronized和volatile可以让数据在修改后**立即写回主存**。
   >
   > 1.  volatile 关键字。当一个共享变量被 volatile 关键字修饰时，这个变量被修改后会立即刷新到主内存，保证其他线程看到的值一定是最新的。
   > 2. synchronized 关键字。线程进入 synchronized 代码块后，线程会获取到 lock，将会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程执行 unlock。
   > 3. final 关键字也可以保证可见性。final 关键字修饰的变量，在构造器中一旦初始化完成，如果没有对象逸出（指对象没有初始化完成就可以被别的线程使用），那么其他线程都就可以看见 final 修饰的变量。

   **3）有序性**

   有序性是指程序执行的顺序按照代码的先后顺序执行。

   > **如何解决？**
   >
   > 1.  volatile 关键字。通过在主存中加入【内存屏障】来达到【禁止指令重排序】，来保证有序性。
   > 2. synchronized 关键字。一个变量在同一时刻只能被一个线程 lock，并且必须 unlock 后，其他线程才可以重新 lock，使得被 synchronized 修饰的代码块在多线程之间是串行执行的。

5. happen-before八条原则

   **1）happen-before是什么**

   > happen-before是JMM最核心的概念,一共有8条规则,
   >
   > JMM可以通过**happens-before关系向程序员提供跨线程的内存可见性保证**（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。
   >
   > **具体的定义为：**
   > 1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
   >
   > 2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

   **2）具体规则：**

   >   　　  1. 单线程happens-before原则：在同一个线程中，书写在前面的操作happens-before后面的操作。
   >
   >   　　  2. 锁的happens-before原则：同一个锁的unlock操作happens-before此锁的lock操作。
   >
   >   　　     > 如果没有这条规则，那么在多线程环境下，一个线程在释放锁之前，另一个线程可能已经获取到了同一个锁，并且可能会产生数据竞争和不一致的结果。
   >
   >   　　  3. volatile变量的happens-before原则： 对一个volatile变量的写操作happens-before对此变量的读操作。
   >
   >   　　     > 如果没有这条规则，一个线程可能会在读取`volatile`变量时得到过期的或者不一致的值，因为其他线程可能还未完成对该变量的写操作。
   >
   >   　　  4. happens-before的传递性原则： 如果A操作 happens-before B操作，B操作happens-before C操作，那么A操作happens-before C操作。
   >
   >   　　  5. 线程启动的happens-before原则：同一个线程的start方法happens-before此线程的其它方法。
   >
   >   　　  6. 线程中断的happens-before原则：对线程interrupt方法的调用happens-before被中断线程**检测到中断状态**的操作。
   >
   >   　　  7. 线程终结的happens-before原则：一个线程的所有操作都先于其他线程检测到该线程的终止。
   >
   >   　　　　8. 对象创建的happens-before原则：一个对象的初始化完成先于他的finalize方法调用。



参考：

​		https://blog.csdn.net/oschina_41790905/article/details/108857973

​		硬件内存模型：https://blog.csdn.net/weixin_45541247/article/details/118446356