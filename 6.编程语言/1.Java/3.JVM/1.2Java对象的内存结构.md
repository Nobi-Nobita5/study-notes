参考：https://blog.csdn.net/weixin_45541247/article/details/118446356

#### 一、对象的内存结构

![image-20230310111822338](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310111822338.png)

对象在内存的分布分为三大部分，对象头，实例数据和对齐。

* 对象头

  对象头里面主要分为markword，类指针和数组长度（如果是数组对象的话）

  * markword

    ![image-20230310094349826](http://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310094349826.png?OSSAccessKeyId=LTAI5tCou6b1axdozAZhA4qP&Expires=9000000001&Signature=VzO7F7TubW75/750Fu9qNaNMPB4=)
    
    **markword占用8字节**（这里针对64位计算机，下同），它里面的内容会随着对象的状态改变而改变，主要是无锁，偏向锁，轻量级锁，重量级锁，GC几种状态，如上图。需要注意一下分代年龄是用4bit来记录了，所以最大年龄只能记录到15，所以分代年龄设置为大于15是不正确的。
    
    根据上面内容可以知道，**synchronized锁有四种状态**：无锁，偏向锁、轻量级锁和重量级锁，【在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，以**减少阻塞和唤醒线程的频率**，从而减少CPU的内核态切换】。下面介绍四种状态和其之间的转换。
    
    > 1. 当一个对象被创建之后，还没有线程进入，这个时候对象处于**无锁状态**
    >
    > 2. 当锁处于无锁状态时，有一个线程A访问同步块并获取锁时，**对象状态升级为偏向锁状态，**会在对象头和栈帧中的锁记录记录线程ID，以后该线程在进入和退出同步块时**不需要进行CAS操作**来进行加锁和解锁，只需要简单的测试一下对象头中的线程ID和当前线程是否一致。
    >
    >    偏向锁被设计为有竞争的时候才会释放。
    >
    > 3. 过了一会，如果又有一个线程B过来获取锁，此时会判断A是否处于存活状态，如果非存活状态，那么锁对象就变成无锁状态，B可以继续拿到锁，把里面偏向锁线程ID改为B，如果A是处于存活状态，那么就会**升级为轻量级锁**，锁标志位00。
    >
    >    此时，多个线程竞争锁的过程，就是**各自进行CAS修改**markword的其他内容为指向**线程栈中的锁记录(Lock Record)的指针**（每个线程会在栈中开辟一块叫做**Lock Record的空间**，用于存放**Markword的副本和一个owner指针**。线程栈的owner指针也用于指向对象，这样就实现了**对象和线程的双重绑定**）。
    >    
    > 4. 如果线程修改失败的话，就会自旋，当一个线程自旋10次之后，仍然未获得锁，锁就会**膨胀为重量级锁**，锁标志位10；
    >
    >    成为重量级锁之后，**未获取到锁的线程会进入阻塞队列(EntryList)**，线程不再自旋获取锁，而是**由monitor对线程进行管制**，**串行操作共享变量**。
    >
    > -----------
    >
    > 
    >
    > 问题：什么是CAS？
    >
    > CAS（CompareAndSwap）比较交换，是一种**无锁编程的方法策略**。
    >
    > 很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为**线程阻塞涉及到用户态和内核态切换**的问题。既然synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized的边界做忙循环，**这就是自旋**。如果做了**多次循环发现还没有获得锁，再阻塞**，这样可能是一种更好的策略。
    >
    > **个人理解，尽量让线程【不要被阻塞】，从而减低锁带来的性能消耗，这也是锁升级的目的。**
    >
    > ![image-20230310095452020](http://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310095452020.png?OSSAccessKeyId=LTAI5tCou6b1axdozAZhA4qP&Expires=9000000001&Signature=EIzkebxDyzDWkXgod00Fez1EDfs=)
    
  * 类指针
  
    指向类class文件。建立对象是为了使用对象，我们程序需要通过栈上的引用来操作堆上的具体对象，由于引用在JVM规范里面只规定了一个指向对象的引用，并没有定义这个引用以什么方式去定位访问堆中的对象的具体位置，所以对象的访问方式也是不一样的，目前主流的方式有两种：句柄和直接指针
  
    <img src="https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310111752812.png" alt="image-20230310111752812" style="zoom:70%;" />
  
  * 数组长度
  
    当对象是数组对象时，会比普通对象多一个数组长度的数据，占用4字节，记录着数组的长度。
  
* 实例数据

  这里存储的是对象里定义的变量。

* 对齐

  HotSpot规定对象大小必须是8字节的倍数，所以当对象头大小和实例数据大小达不到这个要求时，就需要使用对齐来占用字节，达到平台要求。就是起着占用符的作用。

* 一个经典面试题（默认参数下Object o = new Object()占用多大内存？）

  64位计算机下：16字节：对象头8字节，实例数据0字节，对齐8字节
