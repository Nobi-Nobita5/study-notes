https://www.bilibili.com/video/BV1QG4y1P7kL?p=11&vd_source=a42a22c289cbef044cb919e34bdf8e25

#### 一、JVM调优思路

https://blog.csdn.net/weixin_47184173/article/details/114919061

> 调优基础命令
>
> jps（查看进程号）
>
> jstat（贴心的护工，实时监控病人信息）
>
> jinfo（查看/修改虚拟机参数）
>
> jmap（堆,对象详情，导出dump日志）
>
> jhat（查看jmap导出的dump日志）
>
> jstack（栈详情，排查死锁，死循环，请求资源超时神器）

JVM（Java虚拟机）调优是一个复杂的过程，需要理解很多底层的细节和概念。以下是一些常用的JVM调优思路：

1. **明确性能目标**：明确你的应用程序需要满足的性能要求。这可能包括响应时间、吞吐量或资源使用量等。只有了解了性能要求，你才能制定出有意义的调优策略。
2. **理解JVM的工作方式**：理解JVM如何管理内存和执行程序，这对于有效的调优至关重要。这包括理解JVM堆的结构，以及垃圾收集器如何工作。
3. **监控和诊断**：使用诸如VisualVM, JConsole, GCViewer等图形化工具监控JVM的运行状况，收集关于性能和资源使用的信息。重要的指标可能包括CPU使用率、内存使用率、垃圾收集的时间和频率等。
4. **调优策略**：有多种可能的调优策略，具体取决于你的应用程序和其性能要求。这可能包括：
   - **调整堆大小**：如果你的应用程序使用了大量的内存，你可能需要增加JVM堆的大小。但是，这可能会增加垃圾收集的时间，因此需要权衡。
   - **选择合适的垃圾收集器**：Java有多种垃圾收集器，包括Serial GC，Parallel GC，CMS（Concurrent Mark Sweep），G1（Garbage First）等，每种垃圾收集器有不同的特性和用途，需要根据应用程序的需求选择合适的垃圾收集器。
   - **调整垃圾收集器参数**：大多数垃圾收集器都有一些参数可以调整，以优化其性能。例如，你可能需要调整垃圾收集的频率或内存回收的阈值。
5. **测试和反馈**：在进行任何调优之后，都应该进行性能测试，以确认是否达到了预期的效果。这可能包括运行基准测试，或者在实际的生产环境中进行监控。如果结果不满意，你可能需要回到前面的步骤，继续进行调优。

请注意，每个应用程序都是独特的，没有一种调优策略适用于所有情况。你需要根据你的具体情况和性能要求进行决策。

#### 二、JVM常见问题及定位

1. 频繁full Gc最终出现OOM的问题

   [JVM系列-调优实战案例：频繁FullGC和OOM案例_full gc和oom_诸葛小猿的博客-CSDN博客](https://blog.csdn.net/wuxiaolongah/article/details/114461027)

   [频繁发生fullgc的原因和定位思路 - mushishi - 博客园 (cnblogs.com)](https://www.cnblogs.com/mushishi/p/14553105.html#:~:text=频繁full gc会导致 1. 机器 cpu 负载过高 2. 频繁,系统无法请求处理或者过慢， 接口无关 全面性的 出现以上异常的时候，要第一时间反应过来可能是 full gc的问题 频繁full gc的常见原因)

   https://blog.csdn.net/qq_27022339/article/details/121040122

   https://blog.csdn.net/zhengzhaoyang122/article/details/115772104

   > MAT可视化工具分析dump日志，定位问题对象
   >
   > MAT的强大之处主要在于对堆与对象的底层分析

2. CPU彪高的问题

   > arthas命令行工具，定位问题线程
   >
   > 如：dashboard（主监控）

#### 三、定位问题后，如何分析解决问题

我们使用调优工具能将问题发的线程，原因（例如OOM）定位到后，依然需要去在代码中寻找具体的问题原因。此时，我们接着提供问题一些异常分析思路。

**超大对象**
代码中创建了很多大对象 （例如数据库查询一个超级大的list报表）, 且一直因为被引用不能被回收，这些大对象会进入老年代，导致内存一直被占用，很容易引发 GC 甚至是 OOM。

**超过预期访问量**
通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。比如如果一个系统高峰期的内存需求需要 2 个 G 的堆空间，但是堆空间设置比较小，导致内存不够，导致 JVM 发起频繁的 GC 甚至 OOM。

**过多使用 Finalizer（一般很少）**
过度使用终结器（Finalizer），对象没有立即被 GC，Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐，程序消耗了所有的可用资源，最后抛出 OutOfMemoryError 。（所以这个拯救线程真的就是为了面试而存在的玩意儿）。

**内存泄漏**
【**即大对象引用没有被释放掉**】，JVM无法对其自动回收。如果观察一个系统，每次进行 FullGC 发现堆空间回收的比例比较小，尤其是老年代，同时对象越来越多，这个时候可以判断是有可能发生内存泄漏。内存溢出不一定是代码问题，但是**泄漏一定是代码问题**。

**长生命周期的对象持有短生命周期对象的引用**
例如将 ArrayList 设置为静态变量，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏

**连接未关闭**
如数据库连接、网络连接和 IO 连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象。

**变量作用域不合理**
例如，一个变量的定义的作用范围大于其使用范围，如果没有及时地把对象设置为 null，也会导致内存泄漏。

**内部类持有外部类**
Java 的非静态内部类的这种创建方式，会隐式地持有外部类的引用，而且默认情况下这个引用是强引用，因此，如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏（垃圾回收器会回收掉外部类的实例，但由于内部类持有外部类的引用，导致垃圾回收器不能正常工作）

解决方法：你可以在**内部类的内部显示持有一个外部类的软引用(或弱引用)**，并通过构造方法的方式传递进来，在内部类的使用过程中，先判断一下外部类是否被回收；

**集合中对象**Hash值改变
在集合中，如果修改了对象中的那些参与计算哈希值的字段，会导致无法从集合中单独删除当前对象，造成内存泄露。

优化的三个角度

1. 程序优化，效果通常非常大

2. 扩容，如果金钱的成本比较小，不要和自己过不去；

3. 参数调优，在成本、吞吐量、延迟之间找一个平衡点