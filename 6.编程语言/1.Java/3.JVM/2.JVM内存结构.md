**Java的内存分配原理**与C/C++不同，C/C++每次申请内存时都要**malloc**进行系统调用，而**系统调用发生在内核空间**，每次都要中断进行切换，这需要一定的开销，而**Java虚拟机是先一次性分配一块较大的空间（可以通过参数控制）**，然后每次new时都在该空间上进行分配和释放，**减少了系统调用的次数**，节省了一定的开销，这有点类似于内存池的概念；

JVM将其管理的**内存区（运行时数据区）**划分为几个不同的数据区，各司其职，划分大概包括以下几个运行时数据区：**程序计数器，本机方法栈，虚拟机栈，堆，方法区**。

#### 一、方法区(Method Area)：

**JVM规范把方法区描述为堆的一个逻辑部分**，存放着**类信息，常量，静态变量，运行时常量池（用于存放编译期生成的各种字面量和符号引用）**等数据。JDK1.7之前方法区的具体实现叫做永久代(Perm space)，1.7之后叫做元空间(meta space)，两者结构区别为元数据区把运行时常量池里面的字符串常量池挪到了堆中。

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

~~~java
因为元空间使用的是【直接内存】，只受本机可用内存的限制，而永久代有一个jvm设置的固定大小上限，无法进行调整。虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
1） 当元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace。
2） 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
~~~

#### 二、堆(Heap)：

1）堆是JVM管理内存中最大的一块，用于存放对象，几乎所有对象都要在这里分配内存；这里为什么说是几乎所有呢，因为随着**JIT编译器和逃逸分析技术**的发展，对象也可以栈上分配内存了。

**什么是JIT编译器？**

~~~java
在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。

第一段编译就是javac命令。

在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。

引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。
~~~

​		**什么是逃逸分析技术？**

~~~java
   概念：在Java虚拟机中，对象是在堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。逃逸分析并不成熟。
   作用：
       1）同步省略
       		在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做同步省略，也叫**锁消除**。
       2）标量替换
       		标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
			在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。
   逃逸分析：
       基本行为是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
   例如以下代码：
   public static StringBuffer craeteStringBuffer(String s1, String s2) {
    	StringBuffer sb = new StringBuffer();
    	sb.append(s1);
    	sb.append(s2);
    	return sb;
	}
 
	public static String createStringBuffer(String s1, String s2) {
    	StringBuffer sb = new StringBuffer();
    	sb.append(s1);
    	sb.append(s2);
    	return sb.toString();
	}
第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。
~~~

#### 三、栈(Stack)：

每当创建一个线程时，JVM就会为这个线程创建一个对应的 Java 栈。在这个 Java 栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储**局部变量表、操作数栈、方法返回值、动态链接**等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在 Java 栈中入栈到出栈的过程，**所以栈帧内存会随着方法运行结束自动释放**。

#### 四、程序计数器(PC Register)：

**当前线程字节码行号指示器**，线程的恢复，循环，跳转等都需要依赖它来完成。比如A线程执行代码到第五行了，此时A线程被CPU挂起，去执行B线程，后续继续执行A的时候，难道代码要从头执行？当然不是，拿到计数器所记录的行号，往下继续执行。

#### 五、本地方法栈(Native Method Stack)：

本地方法栈和虚拟机栈差不多，区别在于，虚拟机栈为虚拟机执行我们写的方法，**本地方法栈为虚拟机执行native方法**。

![image-20230302150516274](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230302150516274.png)

#### 六、方法运行时变量的存储区域

![image-20230302173453576](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230302173453576.png)





JVM内存结构参考：https://blog.csdn.net/weixin_45541247/article/details/118446356

​							  	https://www.bilibili.com/video/BV12t411u726

JIT、逃逸分析参考：https://blog.csdn.net/xmd415606062/article/details/88693307
