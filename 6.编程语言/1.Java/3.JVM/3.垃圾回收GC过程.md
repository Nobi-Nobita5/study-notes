---



> 了解垃圾回收之前，得先了解JVM是怎么分配内存的，然后识别哪些内存是垃圾需要回收，最后才是用什么方式回收。
>
> **Java的内存分配原理与C/C++不同**，C/C++每次申请内存时都要malloc进行系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。
>
> java一般内存申请有两种：**静态内存和动态内存**。很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。根据上面我们知道，java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。**但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。**
>
> 总之Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而**Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题；**

**对于堆(Heap)中的内存分代概念**，随着内存大小的变化和垃圾回收器的升级变化，起初内存是**逻辑分代，物理也分代**；到了**G1垃圾回收器**的时候，就是**逻辑分代，但是物理没有分代**了；后面到了**ZGC**的时候，就没有分代这个概念了。(JDK17是第一个开始推出成熟的ZGC的长期支持的ZGC版本)

**前期那种情况：**
**堆分为年轻代和老年代，默认比例是1:2，年轻代又分为Eden区，s0区，s1区（也可以说，s区分为from区和to区），比例是8：1：1**

#### 一、检测出垃圾

1）引用计数法：给一个对象添加引用计数器，每当有一个地方引用它，计数器就加1；引用失效就减1。但如果两个对象相互引用，除此之外没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是垃圾对象。但由于计数器不为0，导致无法回收。所以还有下面这种方法。

**注：弱引用是一种不会增加对象引用计数的引用方式。**

2）**可达性分析法**：因为根集对象在运行时都是不能回收内存的，所以我们以**根集**对象为起始点进行搜索，如果有对象不可达的话，便是垃圾对象。

**根集：**Java栈中引用的对象、本地方法中引用的对象、方法区中常量引用的对象、方法区中类静态变量引用的对象等。						

#### 二、垃圾回收算法及分代GC过程

找到垃圾后就要通过垃圾回收算法进行垃圾的回收了，垃圾回收算法主要分为这么几种：标记清除，标记整理，复制

1）标记清除

循环一遍，将从根集开始**可达的对象做好标记**，将**不可达的垃圾对象**对应的物理内存释放掉。缺点：会产生内存碎

2）标记整理

将存活对象移动到垃圾对象前面。优点：不会产生内存碎片；缺点：效率低，涉及到对象的大量挪动。

3）复制

将内存一份为二，每次只用其中一部分，将存活的对象拷贝到另外一份中。缺点：造成内存的浪费，每次只能用一部分；优点是快，不会产生内存碎片

4）分代

**1. 为什么要分代应用GC算法：**

> **根据不同内存区域内对象存活时间的不同，采用不同回收算法，提高效率**；一般由于**年轻代对象存活时间短，需要频繁GC，采用复制算法**，而**老年代对象一般存活时间长，垃圾对象相对较少，故采用标记整理或者标记清除**。

**2. 分代算法对于堆内存区域的划分：**

> **堆分为年轻代和老年代，默认比例是1:2，年轻代又分为Eden区，s0，s1区，比例是8：1：1**。
>
> 1. **使用**对象最多和**频率**最高的就是在Young Generation中，通过s0，s1区就避免过于频繁的产生FullGC（Old Generation满了一般都会产生FullGC）
>
> 2. 虚拟机在进行MinorGC（新生代的Young GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。**如果Full GC后还不够就OOM了**。
>
> 3. 如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的速度是远远低于Young Generation回收速度。**因此实际分配要考虑年老代和新生代的比例，考虑Eden和survives的比例。**
>
> 4. **Permanent Generation（永久代）中发生GC的时候也对性能影响非常大，也是Full GC。**
>     ![image-20230303155819805](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303155819805.png)
>
> 5. **young GC、old GC和Full GC的区别、什么时候触发young gc和Full GC？**
>
>   > 1) 为什么Full GC比young GC慢很多？
>   >
>   >    - young GC：新生代中的对象朝生夕死，所以 Minor GC 非常频繁，使用复制算法，回收速度也比较快。
>   >    - old GC（Major GC）：指的是收集老年代，**CMS 是这个模式，CMS在Old GC之后内存还不能满足，就会触发Full GC。G1不会存在Old GC，而是直接触发Mixed GC （Mixed是G1中独有的概念）。**
>   >
>   >    - Full GC：速度相比young GC慢很多。**因为Full GC需要收集整个过程，包括新生代、老年代、永久代（JDK1.8之前），回收的对象多。**
>   >
>   > 2) 什么时候触发young gc？
>   >    对象优先在新生代 Eden （衣等）区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。
>   >
>   > 3) 什么时候触发old GC？
>   >
>   >    * Minor GC 后，老年代放不下了也会触发 Old GC。
>   >    * 开启**分配担保机制**，根据**历次** Minor GC 后进入老年代的对象大于当前老年代内存大小，**判断 Minor GC 有风险**，则会触发 Old GC；
>   >    * 注：触发条件和Full GC触发条件其中的几个是差不多的。
>   >
>   > 4) 什么时候会触发Full GC？
>   >
>   >    * 调用 System.gc() 方法时，会建议JVM进行Full GC，此方法不建议使用。
>   >    * 新生代使用的是复制算法，为了内存利用率，只使用其中一个 Survivor 空间来做轮换备份，因此如果大量对象在 Minor GC 后仍然存活，导致 Survivor 空间不够用，就会通过**分配担保机制**，将多出来的对象提前转到老年代，此时如果老年代的可用内存小于**该对象**的大小，就会触发 Full GC。
>   >    * 当老年代中最大可用的连续空间小于历代晋升到老年代的对象的平均大小时，会触发Full GC 来让老年代腾出更多的空间。
>   >    * 永久代（JDK1.8之前）空间不足时，也会发生Full GC。
>

**3. 对象出生以及晋级的详细过程：**

> 1. 对象出生在Eden区，当Eden区快满的时候，触发Young GC，将Eden区和S2(Survives)区存活的对象拷贝到S1(Survives)中,并删除Eden区和S2区中所有的对象。**存活的对象年龄加1。**
>
> 2. 对象继续出生在Eden区，Eden区再满了的时候，再次触发Young GC，将Eden区和S1(Survives)区存活的对象拷贝到S2(Survives)中,并删除Eden区和S1区中所有的对象。**存活的对象年龄加1。**
> 3. 对象年龄到达15岁时，就会被晋升到**老年代中**。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

#### 三、垃圾回收器

基于上面的垃圾回收算法，多种垃圾回收器就被开发出来，真正执行垃圾的回收。常见的回收器组合大概分为这么几类：单线程的Serial+Serial Old，多线程的Parallel Scavenge+Parallel Old(PS+PO)，PN+CMS,G1,ZGC

**1）Serial+Serial Old、Parallel Scavenge+Parallel Old(PS+PO) 执行垃圾回收的流程：**

![image-20230303181928265](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303181928265.png)

**可见这4种垃圾回收器（两种组合）在执行垃圾回收线程时，都需要STW，JVM停顿时间比较长**

**2）Parallel New + CMS （PN + CMS）垃圾回收器**

1. PN是年轻代垃圾回收器的一种，PS的增强版，是为了适配CMS。

2. **CMS垃圾回收器是一种跨时代的垃圾回收器，因为在它之前垃圾回收线程和工作线程是串行的，它的出现使得两者并行运行，减少了STW停顿时间。**

3. CMS采用的是标记清除垃圾回收算法，会产生内存碎片。其垃圾回收过程分为四步：初始标记，并发标记，重新标记，并发清理

   * 初始标记：**需要STW，但只是标记GC Root对象**，时间很短。

   * 并发标记：**不需要STW，遍历所有 Old 对象。**从GC Roots对象开始沿着引用链遍历的过程，非常耗时，所以这里能跟工作线程并发执行，大大缩短了垃圾回收时间。

   * 重新标记：**需要STW**，对在并发标记里工作线程改动的对象进行重新标记，并发清理阶段清理垃圾。

   * 并发清理：**不需要STW，使用标记清除算法**。但工作线程还在工作，也会产生浮动垃圾，只能等到下次垃圾回收的时候再来清理这部分垃圾了。

   ![image-20230303182644833](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303182644833.png)

4. CMS在标记对象时使用三色标记算法，实现并发标记。

   > 三色标记算法：黑色表示对象自己已被标记以及其引用的对象被标记；灰色表示对象自己被标记了但其引用对象还没被标记；白色表示对象和引用对象都还没被标记。（理论上没被标记到的应该被回收）
   >
   > **问题：**
   >
   > **这过程会有漏标的情况，因为在并行标记阶段，工作线程也在运行，可能会产生新的对象引用，那么引用的该对象就不能被回收。**比如：在并发标记期间，A由于自己和其引用对象都被标记了，所以是黑色了，B由于其引用D还没有被标记，所以B为灰色，D为白色，**假如此时B去掉D的引用，A指向了D**，此时由于A已经是黑色了，**对于黑色的对象，是不会再沿着其引用链往下遍历了的**，然后**从B开始沿着引用链往下遍历也找不到D**了，此时D就会很尴尬，没被标记到，也就是漏标情况。对于没标记到的对象（白色），会认为它是垃圾，可能会将其回收掉，但是此时D还被A引用着喔，很显然不是垃圾，不应该被回收。如图。
   >
   > ![image-20230303210909634](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303210909634.png)
   >
   > **解决办法：**
   >
   > 1. **增量更新**，对应CMS垃圾回收器回收过程中的**重新标记**。**但是得重新遍历一遍其他已经标记过的对象（会遍历到上图中的A对象）。**
   >
   > 2. **SnapshotAtTheBegining（SATB）**：**垃圾回收线程和工作线程并行运行时，若工作线程要删除对象的引用**，这时候做个引用快照（对D做引用快照），存到一张列表里面，后续只要遍历这张表就可以找到D了。
   >
   >    **引用快照的作用:** 后续遍历这张表的时候，找到D，判断是否有引用它的对象，有就做标记，不回收。
   >
   >    **SATB避免了再次遍历其他已经标记过的对象**。**SATB相对增量更新效率会高**(当然SATB可能**造成更多**的**浮动垃圾**)。
   >
   > 3. 注：**CMS用的增量更新，G1用的SATB**。
   
5. CMS垃圾回收器优缺点

   优点：CMS是第一个使得垃圾回收和工作线程可以部分并发运行的垃圾回收器，停顿时间较短

   缺点：

   * 对CPU资源比较敏感，因为是垃圾回收线程和**工作线程并发运行，会抢占工作线程CPU资源**，降低用户执行速度
   * 会产生浮动垃圾**（如上图，重新标记后，工作线程和并发清理同时运行，工作线程运行过程中可能会产生需要回收的对象）**，可能会出现Concurrent Model Failure。前面也说过了并发清理的时候，工作线程有可能会产生垃圾，而这些垃圾只能在下次执行垃圾回收时回收了。正是由于垃圾回收过程，工作线程也要工作，加上浮动垃圾所占空间的影响，所以要**提前留出一部分空间给工作线程工作**，也就是说，**使用CMS情况下，FullGC不能等到老年代满了才触发**，所以有个参数CMSInitiatingOccupancyFraction来指定**老年代使用了多少百分比了就触发FullGC**。但是这里也带来了个问题，**设置多少合适，如果设置太小，那么FullGC频率就太高了；如果设置太大，当CMS垃圾回收过程空间不够的情况，会出现Concurrent Model Failure**，也就是**并发模式失败**，这时就会临时启动Serial Old垃圾回收器来进行垃圾回收，但由于Serial Old是单线程的，会使得停顿时间变得更长。
   * 由于**CMS采用的是标记清除回收算法**，所以就会**产生内存碎片**，当空间碎片过多的时候，会**给大对象分配内存带来很大麻烦**，往往会出现明明老年代内存还很多却不得不触发一次FullGC，为解决该问题，提供了一个参数：UseCMSCompactAtFullCollection，用于进行FullGC的时候，CMS垃圾回收器开启对老年代内存碎片的合并整理，但**整理碎片过程不是并发的**，会使得停顿时间变长，怎么办呢，只能是通过参数CMSFullGCsBeforeCompaction，来设置多少次不带整理碎片的FullGC后运行一次带整理碎片的FullGC来缓和该问题。

**3）G1垃圾回收器（标记整理+复制算法）**

> 1. G1时代堆的内存结构：
>
>    **到了G1垃圾回收器的时代，堆的内存结构，逻辑上分代，但是物理上已经不分代了。**
>
>    如图，Heap被分为一个个Region，每个Region的大小大概是1M~32M。如果一个对象的大小：
>
> ![image-20230303220725570](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303220725570.png)
> 2. 相关名词概念解释
>
>    * 卡表（card table）：卡表将堆划分为一个个卡页（类比物理内存的page），当卡页上的对象有其他引用时，会改变该卡页上的标记位，称之为dirty card。
>
>    * Remembered Set（Rset）：每个Region维护一个Remembered Set（RSet）来记录本Region对象被其他Region对象引用的信息。通过卡表（card table）把相关引用信息，记录到被引用对象所属的RSet中。
>
>    * Collection Set（CSet）：通俗解释就是记录本次需要清理的Region的集合。G1通过跟踪监测**每个Region的垃圾回收价值**，也就是回收后所获得的空间大小和回收所需要的时间的经验值，每次回收后都会将**回收价值记录在一个优先列表里面，这个列表叫做Collection Set（CSet）**，然后**每次回收都会根据CSet优先回收价值较大的Region，意思就是只回收部分垃圾对象，速度很快，（清理大部分垃圾对象，保证系统正常运行即可）**。
>
> 3. G1垃圾收集器的GC过程
>
>    * 年轻代和老年代都用G1垃圾收集器
>
>    * **G1从整体来看是标记整理方法，从两个Region来看是复制算法**
>
>    * Young GC in G1。可以发现Young区GC采用复制算法（Eden和From复制到to），和其他的垃圾收集器没有什么区别。
>
>      ![image-20230303222200690](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303222200690.png)
>
>    * Mix GC，G1中没有单独对Old区进行GC，在对Old区进行GC的时候会对Young区也进行GC。Mix GC是G1中独有的概念。
>
>      1）初次标记：需要STW，对应CMS中的第一步。标记GCRoot对象，同时标记对象对应的Region，并将该Region叫做RootRegion；
>
>      2）扫描整个Old区的所有Region，看这些Region的Rset中是否有被RootRegion直接引用的记录，如果有，则标识出该Region。
>
>      3）并发标记：不需要STW，对应CMS中的第二步。**遍历（2）中标识出的Region中的对象**，将被GCRoot对象引用的对象做标记，并发清理时不回收。
>
>      ​	  注：在CMS的垃圾回收过程中，会从GC Roots对象开始沿着引用链往下遍历对象，这时候有个问题是，如果GC Roots对象在老年代，那么每次YGC的时候，都要遍历老年代的对象来查找有没有对象指向年轻代的对象好做判断是否回收对象？这样做的话每次YGC涉及的范围就比较大了。**而相对于CMS中遍历Old区中的所有对象，Mix GC只需要遍历（2）中标识出的Region中的对象，遍历范围大大缩小了。**
>
>      4）重新标记：需要STW，使用了SATB。注：**SATB相对增量更新效率会高**(当然SATB可能**造成更多**的**浮动垃圾**)。
>
>      5）清理：**与CMS不同的标记清除不同，因为采用复制清除，所以需要STW。**
>
>      ​			**同时对Young区和Old区进行GC。每次回收都会根据CSet优先回收价值较大的Region，意思就是只回收部分垃圾对象，速度很快，（清理大部分垃圾对象，保证系统正常运行即可）**。清理过程如图：
>
>      ![image-20230303224924513](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230303224924513.png)
>    

**4）G1对比CMS提高效率的地方有哪些？**

1. Rset降低了扫描范围（看Rset中是否有被RootRegion直接引用的记录以确定是否回收）。
2. 重新标记阶段采用的SATB（工作线程删除对象的引用时做快照），比CMS的重新增量更新快。
3. 清理阶段虽然造成了STW，但是使用复制算法清理，使内存紧凑，避免了内存碎片。
4. 优先回收价值较大的Region，意思就是只回收部分垃圾对象，速度很快，最大限度的降低了STW的时间。

#### 四、如何优化GC？

1. 尽量不要创建过大的对象或数组。
2. 通过虚拟机的 -Xmn 参数适当调大新生代的大小，让对象尽量在新生代中被回收掉。
3. 通过 -XX:MaxTenuringThreshold 参数调大对象进入老年代的年龄，**让对象尽量在新生代中被回收掉**。
4. 实际分配要考虑年老代和新生代的比例，考虑Eden和survives的比例，避免对象过早进入老年代，因为老年代的回收速度慢。



参考：

​	概念：https://blog.csdn.net/weixin_45541247/article/details/118446356

​	GC过程：https://www.bilibili.com/video/BV13J411g7A1/
