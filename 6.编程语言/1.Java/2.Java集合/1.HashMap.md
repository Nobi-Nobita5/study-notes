#### 一、HashMap底层实现

1）

JDK7：数组+链表

JDK8：数组+链表+红黑树（链表长度大于8就进化成红黑树）

![image-20230314153655659](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230314153655659.png)

2）

大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个实体方块是**嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。**

~~~java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
~~~

3）HashMap的一些关键类属性

1. capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
2. loadFactor：负载因子，默认为 0.75。
3. threshold：扩容的阈值，等于 capacity * loadFactor

#### 二、HashMap扩容

1. 扩容过程：

   > 1. 当HashMap中元素数量达到了容量阈值（默认是当前容量的0.75）时，就会触发扩容操作。
   > 2. 扩容操作首先会创建一个新的数组，其容量是原数组的两倍。
   > 3. 然后，对于原数组中的每个元素，将其重新计算哈希值，并将其移动到新数组的相应位置上。
   > 4. 如果原数组中某个位置上的元素存在冲突，即有多个元素的哈希值相同，那么在新数组中，这些元素仍然会被存储在同一个位置上（链表或红黑树）。
   > 5. 最后，将新数组替换掉原数组，完成扩容操作。

2. 当HashMap中发生哈希冲突时，具体是怎么存放数据的？

   > 当HashMap中发生哈希冲突时，即多个键（key）的哈希值相同，它们需要存储在哈希表的同一个位置上。在这种情况下，HashMap会在该位置上维护一个链表（或者是红黑树），用于存储具有相同哈希值的键值对。具体来说，当发生冲突时，HashMap会执行以下操作：
   >
   > 1. 首先，HashMap会**将新的键值对插入到链表的头部**。
   > 2. 当HashMap需要查找一个键值对时，它首先**计算该键的哈希值**，并在哈希表中查找该哈希值对应的链表。然后，HashMap会**遍历该链表**，找到键值与要查找的键值相同的节点，并返回其值。
   > 3. 当链表的长度达到一定阈值（默认为8）时，HashMap会将该链表**转换成红黑树**，以**提高查找的效率**。
   > 4. 当某个键值对被删除时，HashMap会将它从链表或红黑树中删除。
   >
   > 需要注意的是，由于链表和红黑树的插入和删除操作的时间复杂度为O(1)和O(log n)，因此在哈希冲突的情况下，HashMap的性能并不会受到太大影响。

3. HashMap的hash(Object key)函数是怎么计算key的hash值的，为什么要这么做？

   > hash(Object key)函数会先调用key的hashCode()方法获取key的哈希码，然后通过哈希函数对哈希码进行处理，最终得到key的哈希值。
   >
   > 哈希函数的主要作用是将哈希码映射到HashMap数组的一个位置上。在Java中，HashMap使用了一个称为**“扰动函数”**的哈希函数，其目的是**通过对哈希码进行位运算，使得哈希码的各个位都参与到哈希值的计算中，从而尽可能地减少哈希冲突的发生。**具体来说，扰动函数的实现如下：
   >
   > ~~~java
   > static final int hash(Object key) {
   >     int h;
   >     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   > }
   > ~~~
   >
   > 在这个实现中，首先判断key是否为null，如果是null，则直接返回0作为哈希值。否则，先调用key的hashCode()方法获取哈希码，然后**将哈希码右移16位，并与原哈希码进行异或运算，得到一个扰动后的哈希值。**这个扰动操作可以有效地减少哈希冲突的发生。
   >
   > 需要注意的是，扰动函数并不能完全避免哈希冲突的发生，因此在同一个位置上可能会有多个元素。为了解决这个问题，HashMap使用链表或红黑树等数据结构来存储同一个位置上的元素。当链表或红黑树中的元素数量超过一定阈值时，HashMap会将链表转化为红黑树，以提高查找的效率。

4. 为什么哈希码右移16位再进行异或运算，就能减少哈希冲突的发生？

   > 在计算元素在数组中的位置时，HashMap使用了**哈希值的高16位和低16位进行异或运算的方式**，目的是为了让哈希码更加均匀地分布在数组中。这是因为在计算哈希码时，**原始的哈希码值通常会存在一些规律性**，**例如只有低位有值，高位都是0，这样的哈希码会让元素在数组中的位置分布不均，导致冲突较多，影响HashMap的性能。**
   >
   > 通过对哈希码的高16位和低16位进行异或运算，可以让哈希码更加均匀地分布在数组中，从而减少冲突的概率，提高HashMap的性能。

5. 为什么capacity设置为2的倍数？

   > 在HashMap中，数组的长度capacity一般会被设置为2的幂次方，这是因为在计算元素在数组中位置时，可以通过对哈希码取模运算的方式，利用位运算的高效性来计算索引位置，具体是通过将**哈希码与数组长度减1的结果进行与运算**，可以得到该元素在数组中的位置。这个操作相当于对哈希码进行取模运算，但是**与运算的速度比取模运算更快**。
   >
   > 如：
   >
   > ~~~
   > 哈希码是9： 0000 0000 ... 0000 1001
   > 数组长度是8,数组长度减1是：0000 0000 ... 0000 0111
   > 按位与得到：0000 0000 ... 0000 0001
   > ~~~
   >
   > 故该元素会放在数组中下标为1的位置

#### 三、HashMap的线程安全问题

1. 会产生哪些线程安全问题?。

   1）数据不一致：

   当多个线程同时访问HashMap时，如果一个线程在对HashMap进行扩容，另一个线程在对HashMap进行遍历，由于扩容期间可能会**导致链表中元素的顺序发生变化**，就有可能导致遍历线程获取到的结果与期望不一致。

   2）**死循环问题：**

2. 为什么扩容期间可能会导致链表中元素的顺序发生变化？

   > 在HashMap扩容期间，当一个链表的元素被重新映射到新的数组位置时，**每个Entry 实例元素**的插入顺序可能会发生变化。
   >
   > 这是因为在扩容过程中，元素的重新分布是**基于元素的哈希值和新数组的大小计算的**。
   >
   > 如果**新数组的大小改变了**，元素被分配到的链表位置也会相应地改变，这可能会导致元素在新链表中的顺序与旧链表中的顺序不同。

