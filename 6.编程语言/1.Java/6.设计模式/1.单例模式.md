#### 一、什么是单例模式

保证一个类只有一个实例，并且提供一个访问该全局访问点

#### 二、创建单例模式有哪几种方式？

1. 饿汉式：直接创建实例对象

   > ```java
   > 1.构造器私有化
   > 2.自行创建，用静态变量或静态代码块保存
   > 3.向外提供该实例
   > 3.强调是一个单例，可以用final修饰
   > public class Singleton1 {
   >     public static final Singleton1 INSTANCE = new Singleton1();
   >     //static {
   >     //    INSTANCE = new Singleton2();
   >     //}    
   >     private Singleton1(){
   > 
   >     }
   > }
   > ```

2. 枚举

   > ```java
   > 枚举类型
   > 表示该类型的对象是有限的几个
   > 限定为一个，就成了单例
   > public enum Singleton3 {
   >     INSTANCE;
   > }
   > ```
   
3. 懒汉式，也就是要使用时再创建对象，延迟创建对象
   也叫：双重检验锁方式实现单例模式
   
   ~~~java
   package JavaSE.设计模式.Single;
   /*
   懒汉式，延迟创建对象
   也叫：双重检验锁方式实现单例模式
    */
   public class Singleton4 {
       //采用 volatile 关键字修饰也是很有必要。
       /*INSTANCE = new Singleton4()，这段代码其实是分为三步执行：
       * 1. 为 INSTANCE 分配内存空间
       * 2. 初始化 INSTANCE
       * 3. 将 INSTANCE 指向分配的内存地址
       * 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。
       * */
       private volatile static Singleton4 INSTANCE;
       private Singleton4(){
   
       }
       public static Singleton4 getINSTANCE(){
           /*每个线程进来，不管三七二十一，都要先进入同步代码块再说，如果说现在 INSTANCE 已经不为null了，那么，此时当一个线程进来，先获得锁，
           然后才会执行 if 判断。我们知道加锁是非常影响效率的，所以，如果 INSTANCE 已经不为null，是不是就可以先判断对象是否已经实例过，
           再进入 synchronized 代码块。如下*/
           if (INSTANCE==null) {
               //类对象加锁，获取到该类对象的锁，再执行里面的同步代码块
               synchronized (Singleton4.class) {
                   /*如果把里面的 if 判断去掉，就相当于只对 INSTANCE = new Singleton4() 这一行代码加了个锁，
                   只对一行代码加锁，那岂不是加了个寂寞（加锁的目的就是防止在第二个if判断和new操作之间有别的线程进来！！）*/
                   if (INSTANCE == null) {
                       INSTANCE = new Singleton4();
                   }
               }
           }
           return INSTANCE;
       }
       public void test(){
   
       }
   }
   ~~~

#### 三、单例模式的注意事项

* 不推荐使用反射模式创建单例。因为反射可以**忽略权限检查（setAccessible）**，可能会破坏封装性而导致安全问题。

  如图：单例类Singleton4，在已经有一个实例的前提下。反射依然能够使用 setAccessible(true) 取消Java的访问控制检查,创建新的实例。

  ![image-20230316204657960](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230316204657960.png)

* 可以通过如下方法，防止反射漏洞攻击：

  ~~~java
      //flag为true，表示Singleton类已经被实例化。
  	private static boolean flag = false;
      private Singleton() {
    		//再构造方法中判断，是否属于第二次调用
          if (flag == false) {
              flag = !flag;
          } else {
              throw new RuntimeException("单例模式被侵犯！");
          }
      }
  ~~~

