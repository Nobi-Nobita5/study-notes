1. 定义

   > Java泛型是指在Java中使用参数化类型的机制，它可以让代码更加灵活、类型安全和可读性更高。通过使用泛型，**可以在编译时期检查类型错误**（**我们可以使用泛型参数来指定对象的类型，从而在编译期就可以检查类型是否匹配**），**避免了在运行时期抛出类型转换异常的风险**，同时还可以提高代码的可读性和可维护性。
   >
   > > 例如，如果在不使用泛型的情况下，我们需要将一个Object类型的对象转换为另一种类型，我们需要在运行时进行类型检查和类型转换。如果在类型转换时出现了类型不匹配的情况，就会抛出类型转换异常。

2. 泛型方法

3. 泛型类

4. 类型通配符 **'?'**

   ~~~java
   import java.util.List;
   public class Box<T> {
       private T t;
   
       public void set(T t) {
           this.t = t;
       }
   
       public T get() {
           return t;
       }
   }
   //通配符？不能直接用于定义变量，只能作为任意参数类型传递给 定义好的泛型类，
   //而 T 可以直接代替任意类型，用于定义类、变量、方法
   /*（泛型类型参数使用大写字母表示，例如 T、E、K、V 等。这些字母是无实际含义的，
    只是为了表示泛型类型参数而保留的一些约定。）*/
   class Box1<T> {
       private List<?> t;
   
       public void set(List<?> t) {
           this.t = t;
       }
   
       public List<?> get() {
           return t;
       }
   }
   ~~~

   

5. 类型擦除

   > > 去查查历史就会知道，c#和java在一开始都是不支持泛型的。为了让一个不支持泛型的语言支持泛型，只有两条路可以走，要么以前的非泛型容器保持不变，然后平行的增加一套泛型化的类型。要么直接把已有的非泛型容器扩展为泛型。不添加任何新的泛型版本。
   > > 当时c#从1.1升级到了2.0，代码并不是很多，而且都在微软.net的可控范围，所以选择了第一种实现方式
   > >
   > > 而java的非泛型容器，已经从1.4.2占有到5.0，市面上已经有大量的代码，不得已选择了第二种方法。（之所以是从1.4.2开始，是因为java以前连collection都没有，是一种vector的写法。），而且有一个更重要的原因就是之前提到的向后兼容。所谓的向后兼容，是保证1.5的程序在8.0上还可以运行。（当然指的是二进制兼容，而非源码兼容。）
   >
   > 所以为了向后兼容，让非泛型的java程序在后续支持泛型的jvm上还可以运行，采用了泛型擦除。
   
   > Java类型擦除（Type Erasure）是指在编译时期，泛型类型会被编译器擦除成原始类型。
   >
   > 但Java泛型信息**是否擦除**有如下两种情况：
   >
   > 1. **声明侧泛型信息保留** 例如声明泛型接口，泛型类，泛型方法时的泛型信息
   >
   > 2. **使用侧泛型信息擦除** 例如方法的局部变量等。
   >
   > 泛型信息保留的情况，我们是有能力在运行时**通过反射**获取声明类型的泛型信息的。