> **类加载的缓存机制**将会保证所有加载过的Class都会被**加载到内存**，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class。
>
> 所以当第一次使用一个类时，JVM会**加载**并**初始化**该类，这个过程只会执行一次。在之后的程序执行过程中，如果需要使用该类的对象，只需要创建新的对象实例，而不需要再次加载该类。
>
> 这就是为什么修改了Class文件后，必须重启JVM，程序的修改才会生效。
>
> 热部署的原理：是在应用程序运行期间，使用**特定的类加载器**，重新加载被修改的类，而不必重启JVM。需要注意的是，热部署只能对某些类型的代码修改生效，例如业务逻辑代码和模板文件等，而对于某些类型的代码修改，如修改**类的继承关系或添加新的成员变量**等，则需要重新启动应用程序或服务器。此外，热部署也可能会带来一些潜在的问题，如内存泄漏或类加载器冲突等，因此**在使用热部署时需要注意遵循一些最佳实践。**

#### 一、类加载机制

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。

![image-20230310113013821](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310113013821.png)

![image-20230310112017901](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310112017901.png)

##### 1. 加载

类加载是指将**编译生成的字节码文件**加载到JVM中。

##### 2. 校验

主要目的是为了确保**生成的字节码**是否符合当前虚拟机的要求

##### 3. 准备

在**方法区中**为类变量**分配内存**，并**设置初始值（默认值）**。

> 如public static int v = 8080;
>
> 在准备阶段过后的初始值是 0 而不是 8080，将V赋值为8080的指令是在程序被编译之后，存放于类构造器<client>方法之中。在【初始化】阶段执行。
>
> 但是注意如果声明为final
>
> public static final int v = 8080;
>
> 在编译阶段会为v 生成ConstantValue 属性，在准备阶段虚拟机就会将V赋值为8080。

##### 4. 解析

虚拟机将**常量池中**的**符号引用**替换为**直接引用**的过程。

符号引用就是class 文件中的：

1. CONSTANT_Class_info
2. CONSTANT_Field_info
3. CONSTANT_Method_info

等类型的常量。

##### 5. 初始化

初始化是执行**类构造器<client>方法**的过程。<client>方法是由编译器自动收集类中的**类变量的赋值操作**和**静态语句块**中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕。

注意：通过类名获取Class 对象，使用延迟加载机制。只会进行必要的初始化操作，而不会进行完整的类初始化操作。

> **生成实例化对象**是在**类初始化之后**的过程。在实例化过程中，会为实例对象分配内存，并调用构造方法来初始化实例的成员变量。

#### 二、类加载器

1）类加载器

当Java程序运行时，JVM首先启动，并且在JVM启动的过程中，类加载器就被初始化了。JVM提供了3 种类加载器，以便让应用程序决定如何获取所需的类。

> Bootstrap（根加载器）：也称引导类加载器，**负责加载JVM的核心类库**，例如java.lang包中的类。通常是用本地代码实现的。
>
> **Extension（扩展类加载器）**：**负责加载扩展库（extension libraries）**，从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
>
> **Application Class Loader（应用程序类加载器）**：其父类是Extension。它是应用最广泛的类加载器，**负责加载应用程序中的类文件**。它从类路径（classpath）或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

此外，Java虚拟机还支持**自定义类加载器**，开发人员可以根据需要编写自定义的类加载器，以实现更复杂的类加载方式，例如从网络中加载类文件、动态生成类文件等。

![image-20230310155554541](https://springboot-vue-blog.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230310155554541.png)

2）双亲委派机制

**双亲委派机制**的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，父类加载器判断是否加载过该Class，如果已加载，则返回Class对象（**缓存机制**）；如果没有则委托给祖父类加载器,依次向上，因此，所有的类加载请求最终都应该**被传递到顶层的启动类加载器**中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

**采用双亲委派的一个好处是：**

> 比如加载位于rt.jar 包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object 对象。

3）子类、父类的加载顺序

**父类的静态字段——>父类静态代码块——>子类静态字段——>子类静态代码块——>**

**父类成员变量（非静态字段）——>父类非静态代码块——>父类构造器——>子类成员变量——>子类非静态代码块——>子类构造器**



参考：公众号：Java架构师进阶编程
