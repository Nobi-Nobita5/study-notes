## 第一章 概念和集群操作

### 1 [ZooKeeper](https://so.csdn.net/so/search?q=ZooKeeper&spm=1001.2101.3001.7020) 是什么？

ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

Zookeeper 保证了如下分布式一致性特性：

（1）顺序一致性

（2）原子性

（3）单一视图

（4）可靠性

（5）实时性（最终一致性）

客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。

有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。

### 2 ZooKeeper 提供了什么？

- 文件系统
- 通知机制

### 3 参数解读

* Zookeeper中的配置文件zoo.cfg中参数含义解读

> 我们都知道，Zookeeper要安装在奇数个节点，但是为什么？
>
> Zookeeper的大部分操作都是通过选举产生的。比如，标记一个写是否成功是要在超过一半节点发送写请求成功时才认为有效。同样，Zookeeper选择领导者节点也是在超过一半节点同意时才有效。最后，Zookeeper是否正常是要根据是否超过一半的节点正常才算正常。这是基于CAP的一致性原理。
>
> 现在假如有一个6个节点的Zookeeper集群，根据以上规则：至少一半以上的节点正常集群才算正常，那么此种情况下最多只能允许2个节点失败，即失效容忍度为2。
>
> 假如有一个5个节点的Zookeeper集群，根据以上规则，仍然是允许2个节点失败。
>
> 因此，**从以上例子来看，安装5个节点和6个节点的Zookeeper没有区别，因为失效节点的容忍度是一致的**，那么这样的话，就没有必要多安装一个节点了。
>
> 综上，我们通常说Zookeeper安装在2N-1个节点。

### 4 选举机制

> SID：服务器ID。用来唯一标识一台 ZooKeeper集群中的机器
>
> ZXID：事务ID。ZXID是一个事务ID，用来 标识一次服务器状态的变更。
>
> Epoch：每个Leader任期的代号。

1. 第一次启动（第一个票自己，第二个也票自己，然后**互相对比myid大小**，小的一方交出自己的选票）一共五个服务器

   （1）服务器1启 动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，**不够半数以上（3票）**，选举无法完成，服务器1状态保持为 LOOKING； 

   （2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1） 大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING 

   （3）服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服 务器3的票数已经超过半数，**服务器3当选Leader。服务器1，2更改状态为FOLLOWING**，服务器3更改状态为LEADING；

   （4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为 1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING； 

   （5）服务器5启动，同4一样当小弟。

2. 非第一次启动

   假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为**8、8、8、7、7（服务器状态变更次数可能是不同的，因为存在半数机制，如服务器处理写请求时，半数同意的服务器会更改事务id）**，并且此时SID为3的服务器是Leader。

   某一时刻， 3和5服务器出现故障，因此开始进行Leader选举。

   SID为1、2、4的机器投票情况： 

    （EPOCH，ZXID，SID ） 

   （1，		8，			1）

   （1，		8，			2） 

   （1，		7，			4） 

   选举Leader规则： ①EPOCH大的直接胜出 ②EPOCH相同，事务id大的胜出 ③事务id相同，服务器id大的胜出

### 5 客户端命令行操作

1. 基本命令

2. 启动客户端 

   ~~~
   bin/zkCli.sh -server hadoop102:2181
   ~~~

3. znode 节点数据信息

### 6 znode节点详解

* ##### ZooKeeper[命名空间](https://so.csdn.net/so/search?q=命名空间&spm=1001.2101.3001.7020)内部拥有一个树状的内存模型，其中各节点被称为znode。它有三部分组成:

  1. **stat**: 此为状态信息, 描述该znode的版本, 权限等信息

  2. **data**: 与该znode关联的数据

  3. **children**: 该znode下的节点

* ##### znode类型(持久, 临时, 有序号, 无序号)

  1. 持久节点(Persistent) : 客户端与 zookeeper 断开连接后, 创建的 znode 依旧存在
  2. 临时节点(Ephemeral) : 客户端与 zookeeper 断开连接后, 创建的 znode 被删除
  3. 持久有序号节点 : 客户端与 zookeeper 断开连接后, 创建的 znode 依旧存在, 只是 zookeeper 给该节点名称顺序编号
  4. 临时有序号节点 : 客户端与 zookeeper 断开连接后, 创建的 znode 被删除, 只是 zookeeper 给该节点名称顺序编号

  创建有序号节点时, znode 名称后会附加一个值, 序号是一个单调递增的计数器, 由父节点维护
  在分布式系统中, 序号可以用于为所有的事件进行全局排序, 这样客户端可以通过序号推断事件的顺序

### 7 监听器原理

1. **监听器原理详解**

​	1）首先要有一个main()线程 

​	2）在main线程中创建Zookeeper客户端，这时就会创建两个线 程，一个负责网络连接通信（connet），一个负责监听（listener）。

​	3）通过connect线程将注册的监听事件发送给Zookeeper。 

​	4）在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。 

​	5）Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。 

​	6）listener线程内部调用了process()方法。

2. **常见的监听**

   1）监听节点数据的变化

   ​	get path [watch]

   2）监听子节点增减的变化

   ​	ls path [watch]

   注册 一次，只能监听一次。想再次监听，需要再次注册

### 8 客户端向服务端写数据流程

> ### ZAB协议与数据一致性
>
> 具体流程如下：
>
> 所有的事务请求必须由唯一的 Leader 服务来处理，Leader 服务将事务请求转换为事务 Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务。如果有半数的 Follower 服务进行了正确的反馈，那么 Leader 就会再次向所有的 Follower 发出 Commit 消息，要求将前一个 Proposal 进行提交。

* 写流程之写入请求直接发送给Leader节点

* 写流程之写入请求发送给follower节点

  **小结：**

  **客户端可以向Zookeeper服务发送具体业务的写请求，该Zookeeper服务根据上述写数据流程执行写操作；**

  **高效的写数据流程使得Zookeeper能在实现分布式处理的同时，快速响应客户端的请求**

## 第二章 服务器动态上下线案例

需求：	

某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知 到主节点服务器的上下线。

## 第 三 章 ZooKeeper 分布式锁案例

什么叫做分布式锁呢？

比如说"进程 1"在使用该资源的时候，会先去获得锁，"进程 1"获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，"进程 1"用完该资源以后就将锁释放掉，让其 他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的 访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁。

```
*  CountDownLatch 能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。
* 它相当于是一个计数器，这个计数器的初始值就是线程的数量，每当一个任务完成后，计数器的值就会减一，
*  当计数器的值为0 时，表示所有的线程都已经任务了，然后在CountDownLatch 上等待的线程就可以恢复执行接下来的任务。
*
* JAVA原生API实现Zookeeper分布式锁思路：
* 加锁成功(节点名称最小)则retrun获取锁，否则waitLatch.await();等待前一个节点waitLatch.countDown();才能获得锁
* 在Zookeeper的监听回调函数process中，监听到连接成功则connectLatch.countDown();监听到waitPath的删除时间则waitLatch.countDown();
```



```
* Curator 框架实现分布式锁案例
* 能实现锁的重入
*
* 可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然可以获取该锁的代码，但不受影响。
*
* 可重入锁最大作用是避免死锁。
* 当一个线程执行一个带锁的代码块或方法，同时代码块或方法里也获取同一个锁。为了避免死锁，此时就可以用可重入锁。
```