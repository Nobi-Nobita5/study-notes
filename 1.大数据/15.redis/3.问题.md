### redis和mysql的数据一致性以及解决方案

https://www.bilibili.com/video/BV1Pt4y1x727/?spm_id_from=333.337.search-card.all.click&vd_source=a42a22c289cbef044cb919e34bdf8e25

1. 起因：有更新请求时，更新mysql和更新redis的操作不能保证原子性。

   1）不能保证**实时一致性：**（**并发的读线程，需要读取到最新数据**）

   * 如果更新了缓存 Redis，还没有来得及更新 MySQL，另一个读线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时读取到的为缓存中的脏数据。 

   * 如果先更新了mysql，还没有来得及更新redis，另一个读线程就来读取，由于没有删除掉缓存，则读取的数据也不是最新的。

   2）不能保证**最终一致性：**（**mysql和redis的数据在更新操作完成后要保持一致**，让其他读线程在读取数据时不会出现mysql和redis数据不一致的情况。）

2. 解决方案

   > 首先，无论是先更新redis还是先更新mysql，都会出现数据不一致的情况。
   >
   > 用**更新**的方式是不可行的，需要使用**删除**的方式

   注：设以下案例mysql和redis的旧值为10，新值为11。

   1）保证**实时一致性：**

   通过加锁，写线程更新mysql和redis时，别的线程不能访问数据。

   2）保证**最终一致性：**

   ##### 方案一: 先删除redis，再更新mysql（不可行）

   例子：

   * 写线程1先删除redis，读线程2读取redis发现为空，则从mysql读取旧值10。
   * 此时redis对应key为空，而mysql对应key的value为10，则回写redis值为10。
   * 而后写线程1再更新mysql值为11，则出现了mysql和redis数据不一致情况。

   ##### 方案二: 先删除redis，再更新mysql，再删除redis（可行）

   <img src="/Users/xhx/Library/Application Support/typora-user-images/image-20230519112145530.png" alt="image-20230519112145530" style="zoom:50%;" />

   例子：

   * 写线程1先删除redis，读线程2读取redis发现为空，则从mysql读取旧值10。

   * 此时redis对应key为空，而mysql对应key的value为10，则回写redis值为10。

   * 而后写线程1再更新mysql值为11，并开始延时等待，等待时间需要让读线程2读取到的10成功返回给接口。

   * 读线程2的请求执行完毕后，写线程1再删除redis。那下一个读线程3的请求到来时，redis为空，读取mysql的值11，并回写11到redis

     > 我们发现该方案，读线程2虽然在写线程1之后发送请求，依然没有读取到最新值11。**不能保证实时一致性**。
     >
     > 但该方案能**保证最终一致性**，即**mysql和redis的数据在更新操作完成后保持一致**。从而其他读线程在读取数据时不会出现mysql和redis数据不一致的情况。

   ##### 方案三：CANAL+MQ来实现最终一致性（可行）