### 1.redis和mysql的数据一致性以及解决方案

https://www.bilibili.com/video/BV1Pt4y1x727/?spm_id_from=333.337.search-card.all.click&vd_source=a42a22c289cbef044cb919e34bdf8e25

1. 起因：有更新请求时，更新mysql和更新redis的操作不能保证原子性。

   1）不能保证**实时一致性：**（**并发的读线程，需要读取到最新数据**）

   * 如果更新了缓存 Redis，还没有来得及更新 MySQL，另一个读线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时读取到的为缓存中的脏数据。 

   * 如果先更新了mysql，还没有来得及更新redis，另一个读线程就来读取，由于没有删除掉缓存，则读取的数据也不是最新的。

   2）不能保证**最终一致性：**（**mysql和redis的数据在更新操作完成后要保持一致**，让其他读线程在读取数据时不会出现mysql和redis数据不一致的情况。）

2. 解决方案

   > 首先，无论是先更新redis还是先更新mysql，都会出现数据不一致的情况。
   >
   > 用**更新**的方式是不可行的，需要使用**删除**的方式

   注：设以下案例mysql和redis的旧值为10，新值为11。

   1）保证**实时一致性：**

   通过加锁，写线程更新mysql和redis时，别的线程不能访问数据。

   2）保证**最终一致性：**

   ##### 方案一: 先删除redis，再更新mysql（不可行）

   例子：

   * 写线程1先删除redis，读线程2读取redis发现为空，则从mysql读取旧值10。
   * 此时redis对应key为空，而mysql对应key的value为10，则回写redis值为10。
   * 而后写线程1再更新mysql值为11，则出现了mysql和redis数据不一致情况。

   ##### 方案二: 先删除redis，再更新mysql，延时等待，再删除redis（可行）

   <img src="/Users/xhx/Library/Application Support/typora-user-images/image-20230519112145530.png" alt="image-20230519112145530" style="zoom:50%;" />

   例子：

   * 写线程1先删除redis，读线程2读取redis发现为空，则从mysql读取旧值10。

   * 此时redis对应key为空，而mysql对应key的value为10，则回写redis值为10。

   * **而后写线程1再更新mysql值为11，并开始延时等待，等待时间需要让读线程2读取到的10成功返回给接口。**

   * 读线程2的请求执行完毕后，写线程1再删除redis。那下一个读线程3的请求到来时，redis为空，读取mysql的值11，并回写11到redis

     > 我们发现该方案，读线程2虽然在写线程1之后发送请求，依然没有读取到最新值11。**不能保证实时一致性**。
     >
     > 但该方案能**保证最终一致性**，即**mysql和redis的数据在更新操作完成后保持一致**。从而其他读线程在读取数据时不会出现mysql和redis数据不一致的情况。

   ##### 方案三：CANAL+MQ来实现最终一致性（可行）
   
   ### 2.Redis大量key同时过期，怎么解决？
   
   Redis的key同时过期可能导致Redis的性能瞬间下降，这通常被称为"过期雪崩"。这是因为在键过期后，Redis需要进行额外的工作来删除过期的键值对，如果大量的键同时过期，这个过程可能消耗大量的计算资源。
   
   以下是一些应对大量key同时过期的策略：
   
   1. **随机化过期时间**：为了避免大量的键同时过期，可以在设置键的过期时间时添加一些随机性。例如，如果你想让一个键在一小时后过期，你可以让它在50分钟到70分钟之间的任意时间过期。这样，键的过期时间就会均匀地分布在一段时间内，而不是全部在同一时间过期。
   
   2. **预先删除或延迟过期**：如果你能提前知道哪些键可能会引发过期雪崩，你可以在它们过期之前就逐渐删除它们，或者将它们的过期时间延后。这可能需要你的应用程序具有一定的智能性，但这是一种有效的策略。
   
   3. **使用TTL(Time-To-Live)不一致的数据**：尽量使用不同的TTL值，使键值对的过期时间尽可能地分散，减少大量键同时过期的可能性。
   
   4. **数据分片**：分布式环境下，可以把数据分布到多个Redis实例上，这样即使一个实例出现问题，也不会影响到其他实例。
   
   5. **设置Redis淘汰策略**：可以配置Redis的淘汰策略为定时淘汰或者定期淘汰，避免过期键的大量积压。但需要注意的是，这两种策略都会增加CPU的使用率，需要根据实际情况选择。
   
   6. **持久化和备份**：保持Redis的持久化开启，并定期进行备份，以防止由于过期雪崩引发的Redis实例崩溃，导致数据丢失。
   
   以上策略可以综合使用，以便更好地防止过期雪崩。最后，由于Redis的工作机制，一些策略可能会对Redis的性能产生影响，因此在选择策略时需要谨慎考虑。