1. 10 亿个 url，每个 url 大小小于 56B，要求去重，内存受限制只有 4G，怎么实现？

   > 答案在【汇总】文件中

   对于去重问题，如果每个数据可以用位存储标识，那么可以用**位图法**解决，这种方法就不会存在误判的场景。

   > **位图法**
   >
   > 适用情况：
   >
   > 1. 每个数据用位来表示的范围较小
   > 2. 用于判断成员是否存在，仅通过一次判断就能知道元素是否存在
   >
   > 例：每个电话号码包括8位整数，如何统计海量不同电话号码的个数？
   >
   > 解决方法：
   >
   > 1. 初始化位图，如一位整数是0～9的任意一个，那么用**10个bit位表示每一个整数的存在与否**
   >
   >    由于我们需要仅通过一次判断就能知道元素是否存在，而且我们要表示的整数个数有10^8次方个，所以我们简历大小为10^8的位图，其中每个位代表一个电话号码。初始时，所有位都设为0。
   >
   >    位图占用的内存：10^8个bit位 = 10^8 / 8 / 1024 / 1024 = **12M**。
   >
   > 2. 遍历电话号码列表：对于每个电话号码，将对应位置的位设置为1。
   >
   > 3. 统计不同电话号码的个数：遍历位图，计算被设置为1的位的个数。每个被设置为1的位对应一个不同的电话号码。因此，被设置为1的位的个数即为不同电话号码的个数。
   >
   > 需要注意的是，使用位图法解决问题的前提是数据集的范围不会太大，而且整体数据量较小。如果数据集范围很大，例如电话号码可能是一个更广泛的整数范围，那么位图法可能会导致内存消耗过大。在这种情况下，可以考虑其他的数据结构和算法来解决统计唯一值的问题，如哈希表、布隆过滤器等。

2. 找出10亿个数中最大的10000个数【TopK问题】

   > 主要看内存是否受限制，能否存的下10亿个数，10亿个浮点数占4G内存。如果内存受限，可以使用一下方法：
   >
   > 1. 参考问题1）对数据先进行分批去重。
   >
   > 2. 对去重后得到的每一批数据进行局部排序（**即快速选择排序**）。找到每一批的前10000大的数。
   >
   >    也是按照内存限制分批一次执行，如果机器是多核，那么可以使用多线程并行处理每个批次数据。
   >
   >    对于多线程可能出现的数据倾斜问题（即先完成的线程会一直等待后完成的线程），可以将数据划分为C*N个partition，每个线程处理完当前Partition后主动获取下一个partition继续处理。
   >
   > 3. 最后，可以将得到的M份前10000大的数，使用小顶堆，获取最终最大的10000个数。
   >
   > TopK频率 问题，如果考虑算法的扩展性和容错性，其实很适合使用MapReduce框架解决。方法如下：
   >
   > 1. 首先，用Hash(x) 函数结合集群机器数量将数据划分（Hash(x) % M）。
   > 2. 对于MapTask，将Hash值相同的数据交给同一个ReduceTask。
   > 3. 对于第一个ReduceTask，采用HashMap统计出每个词出现的频率。对于第二个ReduceTask，统计所有ReduceTask输出数据中的TopK个数。